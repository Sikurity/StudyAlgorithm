<html xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcq="http://purl.org/dc/qualifiers/1.0/" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:fn="http://www.w3.org/2005/xpath-functions"><head>
<title>구글 C++ 스타일 가이드</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="http://www.google.com/favicon.ico" type="image/x-icon" rel="shortcut icon">
<link href="styleguide.css" type="text/css" rel="stylesheet">
<script language="javascript" type="text/javascript">

                function GetElementsByName(name) {
                  // Workaround a bug on old versions of opera.
                  if (document.getElementsByName) {
                    return document.getElementsByName(name);
                  } else {
                    return [document.getElementById(name)];
                  }
                }

                /**
                 * @param {string} namePrefix The prefix of the body name.
                 * @param {function(boolean): boolean} getVisibility Computes the new
                 *     visibility state, given the current one.
                 */
                function ChangeVisibility(namePrefix, getVisibility) {
                  var bodyName = namePrefix + '__body';
                  var buttonName = namePrefix + '__button';
                  var bodyElements = GetElementsByName(bodyName);
                  var linkElement = GetElementsByName('link-' + buttonName)[0];
                  if (bodyElements.length != 1) {
                    throw Error('ShowHideByName() got the wrong number of bodyElements:  ' + 
                        bodyElements.length);
                  } else {
                    var bodyElement = bodyElements[0];
                    var buttonElement = GetElementsByName(buttonName)[0];
                    var isVisible = bodyElement.style.display != "none";
                    if (getVisibility(isVisible)) {
                      bodyElement.style.display = "inline";
                      linkElement.style.display = "block";
                      buttonElement.innerHTML = '▽';
                    } else {
                      bodyElement.style.display = "none";
                      linkElement.style.display = "none";
                      buttonElement.innerHTML = '▶';
                    }
                  }
                }

                function ShowHideByName(namePrefix) {
                  ChangeVisibility(namePrefix, function(old) { return !old; });
                }

                function ShowByName(namePrefix) {
                  ChangeVisibility(namePrefix, function() { return true; });
                }

                function ShowHideAll() {
                  var allButton = GetElementsByName("show_hide_all_button")[0];
                  if (allButton.innerHTML == '▽') {
                    allButton.innerHTML = '▶';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "none", '▶');
                  } else {
                    allButton.innerHTML = '▽';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "inline", '▽');
                  }
                }

                // Recursively sets state of all children
                // of a particular node.
                function SetHiddenState(root, newState, newButton) {
                  for (var i = 0; i != root.length; i++) {
                    SetHiddenState(root[i].childNodes, newState, newButton);
                    if (root[i].className == 'showhide_button')  {
                      root[i].innerHTML = newButton;
                    }
                    if (root[i].className == 'stylepoint_body' ||
                        root[i].className == 'link_button')  {
                      root[i].style.display = newState;
                    }
                  }
                }


                function EndsWith(str, suffix) {
                  var l = str.length - suffix.length;
                  return l >= 0 && str.indexOf(suffix, l) == l;
                }

                function RefreshVisibilityFromHashParam() {
                  var hashRegexp = new RegExp('#([^&#]*)$');
                  var hashMatch = hashRegexp.exec(window.location.href);
                  var anchor = hashMatch && GetElementsByName(hashMatch[1])[0];
                  var node = anchor;
                  var suffix = '__body';
                  while (node) {
                    var id = node.id;
                    var matched = id && EndsWith(id, suffix);
                    if (matched) {
                      var len = id.length - suffix.length;
                      ShowByName(id.substring(0, len));
                      if (anchor.scrollIntoView) {
                        anchor.scrollIntoView();
                      }

                      return;
                    }
                    node = node.parentNode;
                  }
                }

                window.onhashchange = RefreshVisibilityFromHashParam;

                window.onload = function() {
                  // if the URL contains "?showall=y", expand the details of all children
                  var showHideAllRegex = new RegExp("[\\?&](showall)=([^&#]*)");
                  var showHideAllValue = showHideAllRegex.exec(window.location.href);
                  if (showHideAllValue != null) {
                    if (showHideAllValue[2] == "y") {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "inline", '▽');
                    } else {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "none", '▶');
                    }
                  }
                  var showOneRegex = new RegExp("[\\?&](showone)=([^&#]*)");
                  var showOneValue = showOneRegex.exec(window.location.href);
                  if (showOneValue) {
                    ShowHideByName(showOneValue[2]);
                  }


                  RefreshVisibilityFromHashParam();
                }
              </script>
</head>
<body>
<h1>구글 C++ 스타일 가이드</h1>

<p align="right">

Revision 3.274
</p>



<address>
Benjy Weinberger<br>
Craig Silverstein<br>
Gregory Eitzmann<br>
Mark Mentovai<br>
Tashana Landray
</address>

<div style="margin-left: 50%; font-size: 75%;">
<p>
        각 단락에 포함된 추가정보를 보기 위해 다음과 같은 화살표 버튼을 클릭할 수 있다.
        <span class="showhide_button" style="margin-left: 0; float: none">▶</span>.
        모든 추가정보를 한 번에 접고 펼치려면 큰 화살표 버튼을 클릭할 수 있다.
      </p>
<div style=" font-size: larger; margin-left: +2em;">
<span class="showhide_button" style="font-size: 180%; float: none" onclick="javascript:ShowHideAll()" name="show_hide_all_button" id="show_hide_all_button">▶</span>
        모든 추가정보 접기/펼치기
      </div>
</div>
<div class="toc">
<div class="toc_title">차례</div>
<table>
<tbody><tr valign="top" class="">
<td><div class="toc_category"><a href="#%ED%97%A4%EB%8D%94_%ED%8C%8C%EC%9D%BC">헤더 파일</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#_define_%EA%B0%80%EB%93%9C">#define 가드</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%84%EB%B0%A9_%EC%84%A0%EC%96%B8">전방 선언</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%9D%B8%EB%9D%BC%EC%9D%B8_%ED%95%A8%EC%88%98">인라인 함수</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#-inl.h_%ED%8C%8C%EC%9D%BC">-inl.h 파일</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%EC%9D%B8%EC%9E%90_%EC%88%9C%EC%84%9C">함수 인자 순서</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C">include의 이름과 순서</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EB%B2%94%EC%9C%84">범위</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A4%91%EC%B2%A9_%ED%81%B4%EB%9E%98%EC%8A%A4">중첩 클래스</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B9%84%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%95%EC%A0%81_%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%84%EC%97%AD_%ED%95%A8%EC%88%98">비멤버 함수, 정적 멤버 함수, 전역 함수</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A7%80%EC%97%AD_%EB%B3%80%EC%88%98">지역 변수</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%95%EC%A0%81_%EB%B3%80%EC%88%98%EC%99%80_%EC%A0%84%EC%97%AD_%EB%B3%80%EC%88%98">정적 변수와 전역 변수</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4">클래스</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C%EC%9D%98_%EC%9E%91%EC%97%85">생성자에서의 작업</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%B4%88%EA%B8%B0%ED%99%94">초기화</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#explicit_%EC%83%9D%EC%84%B1%EC%9E%90">explicit 생성자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90">복사 생성자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9C%84%EC%9E%84%EA%B3%BC_%EC%83%9D%EC%84%B1%EC%9E%90_%EC%83%81%EC%86%8D">생성자 위임과 생성자 상속</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%8C%80_%ED%81%B4%EB%9E%98%EC%8A%A4">구조체 대 클래스</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%83%81%EC%86%8D">상속</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D">다중 상속</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">인터페이스</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%97%B0%EC%82%B0%EC%9E%90_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C">연산자 오버로드</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4">접근 제어</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%84%A0%EC%96%B8_%EC%88%9C%EC%84%9C">선언 순서</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A7%A7%EC%9D%80_%ED%95%A8%EC%88%98%EB%A5%BC_%EC%93%B0%EA%B8%B0">짧은 함수를 쓰기</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EA%B5%AC%EA%B8%80%EB%A7%8C%EC%9D%98_%ED%8A%B9%EB%B3%84%ED%95%9C_%EB%A7%88%EB%B2%95">구글만의 특별한 마법</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%86%8C%EC%9C%A0%EA%B6%8C%EA%B3%BC_%EC%8A%A4%EB%A7%88%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0">소유권과 스마트 포인터</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#cpplint">cpplint</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EA%B7%B8_%EC%99%B8%EC%9D%98_C++_%EA%B8%B0%EB%8A%A5">그 외의 C++ 기능</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%EC%9D%B8%EC%9E%90">레퍼런스 인자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#rvalue_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4">rvalue 레퍼런스</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C">함수 오버로드</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%94%94%ED%8F%B4%ED%8A%B8_%EC%9D%B8%EC%9E%90">디폴트 인자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B0%80%EB%B3%80%EA%B8%B8%EC%9D%B4_%EB%B0%B0%EC%97%B4%EA%B3%BC_alloca__">가변길이 배열과 alloca()</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#Friends">Friends</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%98%88%EC%99%B8">예외</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#Run-Time_Type_Information__RTTI_">Run-Time Type Information (RTTI)</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%98%95_%EB%B3%80%ED%99%98">형 변환</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%8A%A4%ED%8A%B8%EB%A6%BC">스트림</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%84%EC%9C%84_%EC%A6%9D%EA%B0%80%EC%99%80_%EC%A0%84%EC%9C%84_%EA%B0%90%EC%86%8C">전위 증가와 전위 감소</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#const%EC%9D%98_%EC%82%AC%EC%9A%A9">const의 사용</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#constexpr%EC%9D%98_%EC%82%AC%EC%9A%A9">constexpr의 사용</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%95%EC%88%98_%ED%83%80%EC%9E%85%EB%93%A4">정수 타입들</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#64%EB%B9%84%ED%8A%B8_%EC%9D%B4%EC%8B%9D%EC%84%B1">64비트 이식성</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C">전처리기 매크로</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#0%EA%B3%BC_nullptr/NULL">0과 nullptr/NULL</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#sizeof">sizeof</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#auto">auto</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A4%91%EA%B4%84%ED%98%B8%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%B4%88%EA%B8%B0%ED%99%94">중괄호를 사용한 초기화</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%9E%8C%EB%8B%A4_%ED%91%9C%ED%98%84%EC%8B%9D">람다 표현식</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#Boost">Boost</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#C++11">C++11</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99">이름 규칙</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%9D%BC%EB%B0%98_%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99">일반 이름 규칙</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%8C%8C%EC%9D%BC_%EC%9D%B4%EB%A6%84">파일 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%83%80%EC%9E%85_%EC%9D%B4%EB%A6%84">타입 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B3%80%EC%88%98_%EC%9D%B4%EB%A6%84">변수 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84">상수 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%EC%9D%B4%EB%A6%84">함수 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EC%9D%B4%EB%A6%84">네임스페이스 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%97%B4%EA%B1%B0%ED%98%95_%EC%9D%B4%EB%A6%84">열거형 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84">매크로 이름</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99%EC%9D%98_%EC%98%88%EC%99%B8">이름 규칙의 예외</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EC%A3%BC%EC%84%9D">주석</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A3%BC%EC%84%9D_%EC%8A%A4%ED%83%80%EC%9D%BC">주석 스타일</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%8C%8C%EC%9D%BC_%EC%A3%BC%EC%84%9D">파일 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4_%EC%A3%BC%EC%84%9D">클래스 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%EC%A3%BC%EC%84%9D">함수 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B3%80%EC%88%98_%EC%A3%BC%EC%84%9D">변수 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B5%AC%ED%98%84_%EC%A3%BC%EC%84%9D">구현 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B5%AC%EB%91%90%EC%A0%90,_%EC%B2%A0%EC%9E%90,_%EB%AC%B8%EB%B2%95">구두점, 철자, 문법</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#TODO_%EC%A3%BC%EC%84%9D">TODO 주석</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#Deprecation_%EC%A3%BC%EC%84%9D">Deprecation 주석</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%ED%8F%AC%EB%A7%A4%ED%8C%85">포매팅</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A4%84_%EA%B8%B8%EC%9D%B4">줄 길이</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#ASCII%EA%B0%80_%EC%95%84%EB%8B%8C_%EB%AC%B8%EC%9E%90">ASCII가 아닌 문자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%8C%80_%ED%83%AD">스페이스 대 탭</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%EC%84%A0%EC%96%B8%EA%B3%BC_%EC%A0%95%EC%9D%98">함수 선언과 정의</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%95%A8%EC%88%98_%ED%98%B8%EC%B6%9C">함수 호출</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A4%91%EA%B4%84%ED%98%B8_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8">중괄호 초기화 리스트</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A1%B0%EA%B1%B4%EB%AC%B8">조건문</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B0%98%EB%B3%B5%EB%AC%B8%EA%B3%BC_switch_%EB%AC%B8">반복문과 switch 문</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%ED%91%9C%ED%98%84%EC%8B%9D">포인터와 레퍼런스 표현식</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B6%88%EB%A6%AC%EC%96%B8_%ED%91%9C%ED%98%84%EC%8B%9D">불리언 표현식</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%A6%AC%ED%84%B4%EA%B0%92">리턴값</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%B3%80%EC%88%98%EC%99%80_%EB%B0%B0%EC%97%B4_%EC%B4%88%EA%B8%B0%ED%99%94">변수와 배열 초기화</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%A7%80%EC%8B%9C%EC%9E%90">전처리기 지시자</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%ED%81%B4%EB%9E%98%EC%8A%A4_%ED%8F%AC%EB%A7%B7">클래스 포맷</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%83%9D%EC%84%B1%EC%9E%90_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8">생성자 초기화 리스트</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%ED%8F%AC%EB%A7%A4%ED%8C%85">네임스페이스 포매팅</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B0%80%EB%A1%9C_%EA%B3%B5%EB%B0%B1">가로 공백</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%84%B8%EB%A1%9C_%EA%B3%B5%EB%B0%B1">세로 공백</a></span> </div></td>
</tr>
<tr valign="top" class="">
<td><div class="toc_category"><a href="#%EA%B7%9C%EC%B9%99%EC%9D%98_%EC%98%88%EC%99%B8%EC%82%AC%ED%95%AD">규칙의 예외사항</a></div></td>
<td><div class="toc_stylepoint">
<span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EA%B7%9C%EC%B9%99%EC%9D%84_%EC%A7%80%ED%82%A4%EC%A7%80_%EC%95%8A%EB%8A%94_%EA%B8%B0%EC%A1%B4_%EC%BD%94%EB%93%9C">규칙을 지키지 않는 기존 코드</a></span> <span style="padding-right: 1em; white-space:nowrap;" class=""><a href="#%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C">윈도우 코드</a></span> </div></td>
</tr>
</tbody></table>
</div>
<div class="">
<h2 name="반드시_알아둬야_할_것" id="반드시_알아둬야_할_것">반드시 알아둬야 할 것</h2>
  <div class="">
<h3><a name="%EC%9D%B4_%EA%B0%80%EC%9D%B4%EB%93%9C%EC%9D%98_%EC%88%A8%EA%B2%A8%EC%A7%84_%EC%B6%94%EA%B0%80%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%B3%B4%EB%8A%94_%EB%B2%95" id="이_가이드의_숨겨진_추가정보를_보는_법">이 가이드의 숨겨진 추가정보를 보는 법</a></h3>
<span class="link_button" id="link-이_가이드의_숨겨진_추가정보를_보는_법__button" name="link-이_가이드의_숨겨진_추가정보를_보는_법__button"><a href="?showone=%EC%9D%B4_%EA%B0%80%EC%9D%B4%EB%93%9C%EC%9D%98_%EC%88%A8%EA%B2%A8%EC%A7%84_%EC%B6%94%EA%B0%80%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%B3%B4%EB%8A%94_%EB%B2%95#%EC%9D%B4_%EA%B0%80%EC%9D%B4%EB%93%9C%EC%9D%98_%EC%88%A8%EA%B2%A8%EC%A7%84_%EC%B6%94%EA%B0%80%EC%A0%95%EB%B3%B4%EB%A5%BC_%EB%B3%B4%EB%8A%94_%EB%B2%95">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('이_가이드의_숨겨진_추가정보를_보는_법')" name="이_가이드의_숨겨진_추가정보를_보는_법__button" id="이_가이드의_숨겨진_추가정보를_보는_법__button">▶</span>
     <div style="display:inline;" class="">
       이 스타일 가이드에는 초기 상태에선 숨겨져 있는 많은 추가정보들이
       포함되어 있다. 이들은 왼쪽에 있는 것처럼 세모 아이콘으로 표시된다. 
       세모를 클릭해 보라. 아래에 "만세"가 나타날 것이다.
     </div>
     <div class=""><div class="stylepoint_body" name="이_가이드의_숨겨진_추가정보를_보는_법__body" id="이_가이드의_숨겨진_추가정보를_보는_법__body" style="display: none">
       <p>
        만세! 이제 각 문단의 요점을 클릭해서 추가정보를 펼쳐볼 수 있게 되었다.
        이 문서 상단에 있는 "모든 추가정보 펼치기"를 사용할 수도 있다.
       </p>
     </div></div>
  </div>
</div>
<div class="">
<h2 name="배경" id="배경">배경</h2>
  <p>
    C++은 구글의 여러 오픈소스 프로젝트에서 사용하는 주요한 개발 언어이다. 모든
    C++ 프로그래머가 알고 있듯, C++ 언어는 강력한 기능을 많이 가지고 있으나,
    그 강력함은 복잡함을 야기하고 그로 인해 버그가 생기기 쉬운 코드가 되거나
    읽고 관리하기 어려운 코드가 될 수 있다.
  </p>
  <p>
    이 가이드의 목표는 C++ 코드에서 해야 할 것과 하지 말아야 할 것을 자세하게
    서술해서 복잡함을 관리하는 것이다. 이러한 규칙들은 코더들이 C++ 언어의
    기능들을 계속하여 생산적으로 사용하면서도 기반 코드를 관리가능한 상태로
    유지하기 위한 것이다.
  </p>
  <p>
    '가독성'이라고도 부르는 이 '<em>스타일</em>'은, 우리의 C++ 코드를
    지배하는 컨벤션이다. 이러한 컨벤션은 단순한 소스 파일
    포맷팅보다 훨씬 많은 것을 담고 있기 때문에 <em>스타일</em>이라는 용어는 다소
    그릇된 명칭이다.
  </p>
  <p>
    우리의 기반 코드를 관리할 수 있게 유지하는 한 가지 방법은 <em>일관성</em>을
    강제하는 것이다. 어떤 프로그래머라도 남의 코드를 볼 수 있고 쉽게 이해할 수
    있는 것은 매우 중요하다. 일치된 스타일을 유지하고 컨벤션에 따른다는 것은
    우리가 더 쉽게 "패턴 매칭"을 사용하여 다양한 기호들이 무엇을 의미하고 어떤
    값이 변함없이 참인지를 추측할 수 있다는 것을 의미한다. 모두가 필수적으로
    사용할 숙어와 패턴을 만들면 코드를 이해하는 것이 훨씬 쉬워진다. 가끔은
    어떤 스타일 규칙을 바꾸자는 바람직한 논쟁이 있을 수 있지만, 그럼에도
    불구하고 일관성을 유지하기 위해 규칙을 기존대로 유지한다.
  </p>
  <p>
    이 가이드가 서술하는 또 다른 이슈는 C++의 기능이 비대해지고 있다는 것이다.
    C++은 많은 고급 기능이 있는 거대한 언어이다. 어떤 경우에 우리는 어떤 기능의
    사용을 제한하거나 심지어 금지한다. 이것은 코드를 간단하게 유지하면서
    그 기능들이 흔히 만들 수 있는 문제들과 오류들을 피하기 위해서다.
    이 가이드는 이러한 기능들을 나열하고 왜 사용이 제한되었는지 설명한다.
  </p>
  <p>
    구글에서 개발된 오픈 소스 프로젝트는 이 가이드의 요구사항을 따른다.
  </p>
  <p>
    이 가이드는 C++ 튜토리얼이 아니다. 우리는 독자가 이 언어에 친숙하다고
    가정한다.
  </p>
</div>


<div class="">
<h2 name="헤더_파일" id="헤더_파일">헤더 파일</h2>
  <p>
    기본적으로 모든 <code>.cc</code> 파일은 수반된 <code>.h</code> 파일을 가져야
    한다. 흔한 예외로는 유닛 테스트나 <code>main()</code> 함수만을 가진 작은
    <code>.cc</code> 파일 등이 있다.
  </p>
  <p>
    헤더 파일을 바르게 사용하는 것으로 코드의 가독성과 크기와 성능에 큰 차이를
    만들 수 있다.
  </p>
  <p>
    아래 규칙들은 헤더 파일을 사용할 때 피해야 할 함정들에 관한 가이드이다.
  </p>

  <div class="">
<h3><a name="_define_%EA%B0%80%EB%93%9C" id="_define_가드">#define 가드</a></h3>
<span class="link_button" id="link-_define_가드__button" name="link-_define_가드__button"><a href="?showone=_define_%EA%B0%80%EB%93%9C#_define_%EA%B0%80%EB%93%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('_define_가드')" name="_define_가드__button" id="_define_가드__button">▶</span>
    <div style="display:inline;" class="">
      모든 헤더 파일은 여러 번 포함되지 않기 위해 <code>#define</code> 가드를
      사용해야 한다. 기호의 포맷은
      <code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>
      으로 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="_define_가드__body" id="_define_가드__body" style="display: none">
      <p>
        유일성을 보장하기 위해 <code>#define</code> 가드는 프로젝트의 소스
        트리의 절대 경로에 기반해야 한다. 예를 들어 프로젝트에
        <code>foo/src/bar/baz.h</code> 파일이 있다면 <code>foo</code>는
        아래와 같은 가드를 가져야 한다.
      </p>
      <div class=""><pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_</pre></div>

    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%84%EB%B0%A9_%EC%84%A0%EC%96%B8" id="전방_선언">전방 선언</a></h3>
<span class="link_button" id="link-전방_선언__button" name="link-전방_선언__button"><a href="?showone=%EC%A0%84%EB%B0%A9_%EC%84%A0%EC%96%B8#%EC%A0%84%EB%B0%A9_%EC%84%A0%EC%96%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('전방_선언')" name="전방_선언__button" id="전방_선언__button">▶</span>
    <div style="display:inline;" class="">
        불필요한 <code>#include</code>를 피하기 위해 클래스를 전방
        선언할 수도 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="전방_선언__body" id="전방_선언__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
          "전방 선언"이란 수반되는 정의 없이 클래스나 함수, 템플릿을 선언하는
          것이다. 클라이언트 코드에서 어떤 기호가 실제로 사용되든
          <code>#include</code> 라인은 종종 전방 선언으로 대체할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><ul>
          <li>불필요한 <code>#include</code>는 컴파일러가 더 많은 파일을 열고 더
          많은 입력을 처리하도록 만든다.</li>
          <li>불필요한 <code>#include</code>는 헤더 파일 변경 시 코드를
          더 자주 다시 컴파일하도록 만든다.</li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><ul>
          <li>템플릿, typedef, 디폴트 인자, using 선언과 같은 기능을 쓸 때
          전방 선언의 정확한 형태를 결정하기 힘들 수 있다.</li>
          <li>어떤 코드 조각에서는 전방 선언이 필요한지 전체
          <code>#include</code>가 필요한지 결정하기 힘들 수 있다. 특히 암시적
          변환이 개입될 때 그렇다. 극단적인 경우에는 <code>#include</code>를
          전방 선언으로 대체하면 코드의 의미가 조용히 바뀔 수도 있다.</li>
          <li>헤더에서 여러 기호를 전방 선언하는 것은 단순히 헤더를
          <code>#include</code>하는 것보다 장황해질 수 있다.</li>
          <li>호환성을 깨지 않고 헤더에서 할 수 있었던 변경들이 함수나 템플릿의
          전방 선언 때문에 불가능해질 수 있다. 예를 들어 인자
          타입을 더 넓은 타입으로 바꾼다거나, 디폴트 값이 있는 템플릿 인자를
          추가하는 것 등이 그렇다.</li>
          <li>
<code>std::</code> 네임스페이스의 기호를 전방 선언하면 보통
          예상할 수 없는 결과를 유발한다.</li>
          <li>전방 선언이 가능하도록 코드를 구조화하는 일(예를 들어 객체 멤버
          대신 포인터 멤버를 쓰는 일)은 코드를 더 느리고 더 복잡하게 만들 수
          있다.</li>
          <li>전방 선언으로 얻어지는 실질적인 성능 개선은 증명된 적이 없다.
          </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><ul>
          <li>헤더 파일에 선언된 함수를 사용할 때, 항상 그 헤더를
          <code>#include</code>하라.</li>
          <li>클래스 템플릿을 사용할 때, 헤더 파일을 <code>#include</code>
          하는 것을 선호하라.</li>
          <li>일반적인 클래스를 사용할 때 전방 선언에 의존하는 것은 괜찮으나
          전방 선언이 불충분하거나 부정확한 경우를 조심하라. 고민되는
          경우에는 그냥 적절한 헤더를 <code>#include</code>하라.</li>
          <li>단순히 <code>#include</code>를 피하기 위해서 데이터 멤버를
          포인터로 대체하지 말라.</li>
        </ul>
        항상 필요로 하는 선언 또는 정의를 실제로 제공하는 파일을
        <code>#include</code>하라. 다른 헤더를 거쳐 간접적으로
        가져온 기호에 의존하지 말라. 하나의 예외로 <code>myfile.cc</code>
        파일은 그에 상응하는 <code>myfile.h</code> 헤더에 있는
        <code>#include</code>와 전방 선언에 의존할 수 있다.
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%9D%B8%EB%9D%BC%EC%9D%B8_%ED%95%A8%EC%88%98" id="인라인_함수">인라인 함수</a></h3>
<span class="link_button" id="link-인라인_함수__button" name="link-인라인_함수__button"><a href="?showone=%EC%9D%B8%EB%9D%BC%EC%9D%B8_%ED%95%A8%EC%88%98#%EC%9D%B8%EB%9D%BC%EC%9D%B8_%ED%95%A8%EC%88%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('인라인_함수')" name="인라인_함수__button" id="인라인_함수__button">▶</span>
    <div style="display:inline;" class="">
      함수가 작을 때, 이를테면 10라인이나 그 이하일 정도일 때만 함수를
      인라인으로 정의하라.
    </div>
    <div class=""><div class="stylepoint_body" name="인라인_함수__body" id="인라인_함수__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        일반적인 함수 호출 매커니즘으로 호출하는 대신 컴파일러가 해당
        함수를 인라인 처리할 수 있도록 함수를 선언할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        함수가 짧다면, 인라인 함수는 더 효율적인 오브젝트 코드를 생성할 수 있다.
        접근자나 변경자 혹은 다른 작은 함수, 성능에 결정적인
        함수들을 인라인하는데 부담을 가지지 말라.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        인라인을 과도하게 사용하면 프로그램을 실제 더 느리게 만들 수 있다. 함수
        크기에 따라서 인라인을 하면 함수 크기에 따라 코드 크기가 커질 수도,
        작아질 수도 있다. 아주 작은 접근자 함수를 인라인하면 보통 코드 크기를
        작게 하지만, 반면 매우 큰 함수를 인라인하게 되면 코드 크기를 엄청나게
        크게 만들 수 있다. 최근의 프로세서들은 인스트럭션 캐쉬를 더욱 잘
        활용하기 때문에 작은 코드가 더 빨리 돈다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          괜찮은 판단방법은 길이가 10라인 이상인 함수는 인라인하지 않는 것이다.
          소멸자를 주의하라! 소멸자는 함축적으로 멤버와 상위 클래스의 소멸자를
          부르기 때문에 보이는 것보다 종종 길다.
        </p>
        <p>
          또 하나의 괜찮은 판단방법이 있다. 반복문이나 switch 문이 있는 함수
          (보통의 경우 절대 수행되지 않는 반복문이나 switch 문인 경우를
          제외하고)를 인라인하는 것은 보통 효과적이지 않다.
        </p>
        <p>
          함수가 인라인으로 선언되었다고 해서 항상 인라인되는 것은 아님을
          유의하자. 예를 들면 가상 함수나 재귀 호출 함수는 보통
          인라인되지 않는다. 일반적으로 재귀 호출 함수는 인라인되면 안 된다.
          가상 함수를 인라인하는 이유는 접근자와 변경자의 경우처럼
          주로 클래스 안에 정의를 넣기 위해서이며,
          이는 편의 때문이거나, 하는 일을 문서화하기 위해서이다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="-inl.h_%ED%8C%8C%EC%9D%BC" id="-inl.h_파일">-inl.h 파일</a></h3>
<span class="link_button" id="link--inl.h_파일__button" name="link--inl.h_파일__button"><a href="?showone=-inl.h_%ED%8C%8C%EC%9D%BC#-inl.h_%ED%8C%8C%EC%9D%BC">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('-inl.h_파일')" name="-inl.h_파일__button" id="-inl.h_파일__button">▶</span>
    <div style="display:inline;" class="">
      필요한 경우 복잡한 인라인 함수들을 정의하기 위해
      <code>-inl.h</code> 접미어가 붙은 파일 이름을 사용할 수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="-inl.h_파일__body" id="-inl.h_파일__body" style="display: none">
      <p>
        인라인 함수의 정의는 헤더 파일에 있어야 하며, 이것은 컴파일러가 인라인
        함수 호출부분을 컴파일 할 때 인라인 함수의 정의가 필요하기 때문이다.
        하지만 구현 코드는 <code>.cc</code> 파일에 포함되는 것이 적절하고,
        가독성이나 성능상의 이점이 없는 경우 <code>.h</code> 파일에 실제 코드를
        많이 넣는 것을 좋아하지 않는다.
      </p>
      <p>
        인라인 함수가 짧고 로직이 거의 없는 경우 <code>.h</code> 파일에 넣는
        것이 좋다. 예를 들면 접근자나 변경자들은 당연히 클래스 정의에
        있어야 한다. 구현이나 호출이 더 편리한 경우 더 복잡한 인라인 함수도
        <code>.h</code> 파일에 넣을 수 있으나, 이들이 <code>.h</code>
        파일을 너무 다루기 힘들게 만드는 경우엔 대신 별도의 <code>-inl.h</code>
        파일에 코드를 넣을 수 있다. 이는 클래스 정의와 인라인 함수의 구현을
        분리하면서도 여전히 컴파일러가 필요할 때마다 인라인 함수의 구현을
        사용할 수 있게 한다.
      </p>
      <p>
        <code>-inl.h</code> 파일의 또 다른 사용은 함수 템플릿 정의를 위한
        것이다. 이로써 템플릿 정의를 읽기 쉽도록 유지할 수 있다.
      </p>
      <p>
        <code>-inl.h</code> 파일도 다른 모든 헤더 파일과 마찬가지로
        <a href="#_define_%EA%B0%80%EB%93%9C"><code>#define</code> 가드</a>가 필요하다는
        것을 잊지 말라.
      </p>

    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%EC%9D%B8%EC%9E%90_%EC%88%9C%EC%84%9C" id="함수_인자_순서">함수 인자 순서</a></h3>
<span class="link_button" id="link-함수_인자_순서__button" name="link-함수_인자_순서__button"><a href="?showone=%ED%95%A8%EC%88%98_%EC%9D%B8%EC%9E%90_%EC%88%9C%EC%84%9C#%ED%95%A8%EC%88%98_%EC%9D%B8%EC%9E%90_%EC%88%9C%EC%84%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_인자_순서')" name="함수_인자_순서__button" id="함수_인자_순서__button">▶</span>
    <div style="display:inline;" class="">
      함수를 정의할 때 인자 순서는 입력이 먼저이고 출력이 다음이다.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_인자_순서__body" id="함수_인자_순서__body" style="display: none">
      <p>
        C/C++ 함수의 인자는 입력이거나 출력이거나 둘 다일 수
        있다. 입력 인자는 보통 값(value)이거나 <code>const</code> 레퍼런스이고,
        출력과 입출력 인자는 <code>const</code>가 아닌 포인터가 될 것이다. 함수
        인자를 순서에 따라 배열할 때, 모든 입력 전용 인자를 출력 인자보다 앞에
        두라. 특히 단순히 새롭다는 이유로 새 인자를 함수 마지막에 추가하지 말라.
        새로운 입력 전용 인자가 있으면 출력 인자 앞에 두라.
      </p>
      <p>
        이것은 엄격한 규칙은 아니다. 입력이면서 출력인 인자(종종 클래스와
        구조체)는 일을 복잡하게 만든다. 그리고 언제나 그렇듯이 관련된 함수들과의
        일관성을 위해 이 규칙을 따르지 않을 수 있다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C" id="include의_이름과_순서">include의 이름과 순서</a></h3>
<span class="link_button" id="link-include의_이름과_순서__button" name="link-include의_이름과_순서__button"><a href="?showone=include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C#include%EC%9D%98_%EC%9D%B4%EB%A6%84%EA%B3%BC_%EC%88%9C%EC%84%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('include의_이름과_순서')" name="include의_이름과_순서__button" id="include의_이름과_순서__button">▶</span>
    <div style="display:inline;" class="">
      가독성을 높이고 숨겨진 종속성을 피하기 위해서 다음과 같은 순서를 사용하라.
      C 라이브러리, C++ 라이브러리, 다른 라이브러리들의 <code>.h</code>,
      현재 프로젝트의 <code>.h</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="include의_이름과_순서__body" id="include의_이름과_순서__body" style="display: none">
      <p>
        모든 프로젝트의 헤더 파일은 UNIX의 디렉터리 단축 표시인 <code>.</code>
        (현재 디렉터리)이나 <code>..</code> (부모 디렉터리)을 사용하지 않고
        프로젝트의 소스 디렉터리의 하위 요소로 나열되어야 한다. 예를 들면
        <code>google-awesome-project/src/base/logging.h</code>는 이와 같이
        <code>#include</code>되어야 한다.
      </p>
      <div class=""><pre>#include "base/logging.h"</pre></div>
      <p>
        주된 목적이 <code><var>dir2/foo2</var>.h</code>에 있는 것들을 구현하거나
        테스트하기 위한 <code><var>dir/foo</var>.cc</code>나
        <code><var>dir/foo_test</var>.cc</code>에서 include를 아래처럼
        순서에 따라 배열하라.
      </p>
      <ol>
        <li> <code><var>dir2/foo2</var>.h</code> (아래 설명 참조).
        </li>
        <li> C 시스템 파일</li>
        <li> C++ 시스템 파일</li>
        <li> 다른 라이브러리의 <code>.h</code> 파일</li>
        <li> 현재 프로젝트의 <code>.h</code> 파일</li>
      </ol>
      <p>
        이 순서에 따르면 <code><var>dir2/foo2</var>.h</code>가 어느
        필요한 include들을 빠뜨린 경우에 <code><var>dir/foo</var>.cc</code>나
        <code><var>dir/foo</var>_test.cc</code>의 빌드는 망가진다. 그러므로 이
        규칙은 다른 패키지에서 작업하는 무고한 사람들의 빌드 실패보다 이
        파일에서 작업하는 사람들의 빌드 실패를 먼저 보여주도록 한다.
      </p>
      <p>
        <code><var>dir/foo</var>.cc</code>와
        <code><var>dir2/foo2</var>.h</code>는 종종 같은 디렉터리에 있지만,
        다른 디렉터리에 있을 수 있다 (예를 들면
        <code>base/basictypes_test.cc</code>와
        <code>base/basictypes.h</code>처럼).
      </p>
      <p>
        각각의 부분 안에서 include는 알파벳 순서로 나열되어야 한다. 오래된
        코드는 이 규칙에 따르지 않을 수 있고 편리할 때 수정되어야 한다는 것에
        주목하라.
      </p>
      <p>
        예를 들자면
        <code>google-awesome-project/src/foo/internal/fooserver.cc</code>의
        include들은 이렇게 보일 수 있다.
      </p>
      <div class=""><pre>#include "foo/public/fooserver.h"  // 바람직한 위치

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;hash_map&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"</pre></div>
      <p>
        예외: 가끔 시스템에 특정한 코드들은 조건부 include를 필요로 한다. 이런
        코드들은 조건부 include를 다른 include 밑에 둘 수 있다. 당연히, 시스템에
        특정한 코드들을 작고 국한되게 유지하라. 예를 들자면,
      </p>
      <div class=""><pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // LANG_CXX11를 위해

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11</pre></div>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="범위" id="범위">범위</h2>
  <div class="">
<h3><a name="%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4" id="네임스페이스">네임스페이스</a></h3>
<span class="link_button" id="link-네임스페이스__button" name="link-네임스페이스__button"><a href="?showone=%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('네임스페이스')" name="네임스페이스__button" id="네임스페이스__button">▶</span>
    <div style="display:inline;" class="">
      <code>.cc</code> 파일에 이름 없는 네임스페이스 사용을 권장한다. 이름 있는
      네임스페이스는 프로젝트에 기반한, 주로 경로에 기반한 이름을 선택하라.
      <i class="">using 지시자</i>를 사용하지 말라. 인라인 네임스페이스를
      사용하지 말라.
    </div>
    <div class=""><div class="stylepoint_body" name="네임스페이스__body" id="네임스페이스__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        네임스페이스는 전체 영역(전역)을 구획화하여 이름이 부여된 범위로
        분할하는데, 이는 전체 영역(전역)에서의 이름 충돌을 막는 데 유용하다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          네임스페이스는 클래스들로 이루어진 (계층적인) 이름 체계에 더해 추가적인
          (마찬가지로 계층적인) 이름 체계를 형성한다.
        </p>
        <p>
          예를 들면 전체 영역(전역)에서 클래스 <code>Foo</code>를 가진 서로 다른
          두 프로젝트가 있다면, 이들 기호들은 컴파일 시점이나 런타임에 충돌할 수
          있다. 만약 각각의 프로젝트가 그들의 코드를 네임스페이스 안에 둔다면
          <code>project1::Foo</code>와 <code>project2::Foo</code>는 이제
          충돌하지 않는 서로 다른 기호이다.
        </p>
        <p>
          인라인 네임스페이스는 자동적으로 자신의 이름들을 자신을 포함하는
          네임스페이스에 넣는다. 예로 아래 코드 조각을 보라.
        </p>
        <div class=""><pre>namespace X {
inline namespace Y {
  void foo();
}
}</pre></div>
        <p>
          <code>X::Y::foo()</code>와 <code>X::foo()</code>라는 표현은 서로 교환
          가능하다. 인라인 네임스페이스는 원래 버전간 ABI 호환성을 위해 만들어
          졌다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
          클래스들로 이루어진 (계층적인) 이름 체계에 추가적으로 (마찬가지로
          계층적인) 이름 체계를 만들기 때문에, 네임스페이스는 혼동을 줄 수 있다.
        </p>
        <p>
          인라인 네임스페이스는 실제로 선언한 이름들이 그 네임스페이스에
          제한되지 않기 때문에 특히 혼동을 줄 수 있다. 인라인 네임스페이스는
          더 큰 버전 정책의 부분으로서만 유용하다.
        </p>
        <p>
          헤더 파일에서 이름 없는 네임스페이스의 사용은 C++ One Definition Rule
          (ODR)을 쉽게 침범할 수 있다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          네임스페이스는 아래에 설명한 정책에 따라 사용하라. 주어진 예제에서
          보이는 것처럼 네임스페이스 끝에는 주석을 붙이라.
        </p>

        <p class="">
<span class="stylepoint_subsection">이름 없는 네임스페이스</span>
          </p><ul>
            <li> 런타임의 이름 충돌을 피하기 위해 <code>.cc</code> 파일에서 이름
                 없는 네임스페이스는 허용되며 심지어 권장된다.
                 <div class=""><pre>namespace {                           // 이 부분은 .cc 파일에 있다.

// 네임스페이스의 내용은 들여쓰기되지 않는다
enum { kUnused, kEOF, kError };       // 공통으로 사용되는 토큰
bool AtEof() { return pos_ == kEOF; }  // 우리의 네임스페이스의 EOF를 사용한다.

}  // namespace</pre></div>

                 <p>
                   하지만 특정 클래스와 연관이 있는 파일 영역 선언은 이름 없는
                   네임스페이스의 멤버보다는 그 클래스 내부의 타입 또는
                   정적 데이터 멤버나 정적 멤버 함수로서 선언될 수 있다.
                 </p>
                 </li>
            <li> <code>.h</code> 파일에서 이름 없는 네임스페이스를 사용하지
                 말라.</li>
          </ul>
        <p></p>

        <p class="">
<span class="stylepoint_subsection">이름 있는 네임스페이스</span>
          </p><p>
            이름 있는 네임스페이스는 아래와 같이 사용되어야 한다.
          </p>
          <ul>
            <li> 네임스페이스는 include 구문,
                 <a href="http://google-gflags.googlecode.com/">gflags</a>
                 정의/선언, 다른 네임스페이스에 있는 클래스 전방 선언 아래부터
                 전체 소스 파일을 감싼다.
                 <div class=""><pre>// .h 파일의 내부
namespace mynamespace {

// 모든 선언들은 네임스페이스 범위 안에 있다.
// 들여쓰기가 없다는 점을 주목하라.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace</pre></div>
                 <div class=""><pre>// .cc 파일의 내부
namespace mynamespace {

// 함수의 정의는 네임스페이스 범위 안에 있다.
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace</pre></div>
                 <p>
                   전형적인 <code>.cc</code> 파일은 다른 네임스페이스의 클래스를
                   참조하는 등의 이유로 더 복잡해질 수 있다.
                 </p>
                 <div class=""><pre>#include "a.h"

DEFINE_bool(someflag, false, "dummy flag");

class C;  // 전역 네임스페이스 안의 클래스 C의 전방 선언
namespace a { class A; }  // a::A의 전방 선언

namespace b {

...code for b...         // 들여쓰기 없는 코드

}  // namespace b</pre></div>
                 </li>

            <li> <code>std</code> 네임스페이스에는 아무것도 선언하지 말라.
                 표준 라이브러리 클래스들의 전방 선언도 하지 말라.
                 <code>std</code> 네임스페이스에 요소를 선언하는 것은
                 포팅이 불가능한, 정의되지 않은 행동이다. 표준 라이브러리의
                 요소를 선언하려면 해당 헤더 파일을 <code>#include</code>하라.
                 </li>

            <li> 한 네임스페이스에 있는 모든 이름을 활용하기 위한
                 <i class="">using 지시자</i>를 쓸 수 없다.
                 <div class=""><pre class="badcode">// 금지 -- 네임스페이스를 더럽힌다.
using namespace foo;</pre></div>
                 </li>

            <li> <i class="">using 선언</i>을 <code>.cc</code> 파일의
                 어느 곳에서나 사용할 수 있고, <code>.h</code> 파일의 함수와
                 메서드와 클래스 안에서 사용할 수 있다.
                 <div class=""><pre>// .cc 파일에서는 OK.
// .h 파일에서 함수나 메서드, 클래스 안에 있어야 한다.
using ::foo::bar;</pre></div>
                 </li>

            <li> 네임스페이스 별칭은 <code>.cc</code> 파일 어디서나 사용할 수 있고,
                 <code>.h</code> 파일 전체를 감싸고 있는 이름 있는 네임스페이스 안의
                 모든 곳과, 함수나 메서드 안에서 사용할 수 있다.
                 <div class=""><pre>// .cc 파일에서 어떤 공통으로 사용되는 이름에 대한 축약된 접근
namespace fbz = ::foo::bar::baz;

// (.h 파일에서) 어떤 공통으로 사용되는 이름에 대한 축약된 접근
namespace librarian {
// 아래의 별칭은 이 헤더를 include하는 모든 파일에서 (librarian 네임스페이스로)
// 사용 가능하다.
// 그러므로 별칭의 이름은 프로젝트 안에서 일관되게 선택되어야 한다.
namespace pd_s = ::pipeline_diagnostics::sidetable;

inline void my_inline_function() {
  // 네임스페이스 별칭은 함수 (혹은 메서드) 안에 국한된다.
  namespace fbz = ::foo::bar::baz;
  ...
}
}  // namespace librarian</pre></div>
                 <p>
                 <code>.h</code> 파일에 있는 별칭은 그 파일을
                 <code>#include</code>하는 모든 사람에게 보인다는 점에 유의하라.
                 그러므로 (프로젝트 밖에서 활용할 수 있는) 공개 헤더과
                 그 공개 헤더들이 <code>#include</code>하는
                 헤더들은 가능한 한 공개 API를 작게 유지하려는 목적의 일환으로
                 별칭들을 정의하는 것을 피해야 한다.
                 </p>
                 </li>
            <li> 인라인 네임스페이스를 사용하지 말라.</li>
          </ul>
        <p></p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A4%91%EC%B2%A9_%ED%81%B4%EB%9E%98%EC%8A%A4" id="중첩_클래스">중첩 클래스</a></h3>
<span class="link_button" id="link-중첩_클래스__button" name="link-중첩_클래스__button"><a href="?showone=%EC%A4%91%EC%B2%A9_%ED%81%B4%EB%9E%98%EC%8A%A4#%EC%A4%91%EC%B2%A9_%ED%81%B4%EB%9E%98%EC%8A%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('중첩_클래스')" name="중첩_클래스__button" id="중첩_클래스__button">▶</span>
    <div style="display:inline;" class="">
      API의 일부인 경우엔 public 중첩 클래스를 사용할 수 있다.
      하지만 전체 영역(전역)에 선언이 들어가지 않도록
      <a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a>의 사용을 고려하라.
    </div>
    <div class=""><div class="stylepoint_body" name="중첩_클래스__body" id="중첩_클래스__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        클래스는 다른 클래스를 그 안에 정의할 수 있다. 이는
        <i class="">멤버 클래스</i>라고도 부른다.
        </p><div class=""><pre>class Foo {

 private:
  // Bar는 Foo 안에 중첩된 멤버 클래스이다.
  class Bar {
    ...
  };

};</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        중첩 클래스(혹은 멤버 클래스)는 감싼 클래스에 의해서만 사용될 때
        유용하다. 클래스 이름으로 바깥 영역을 더럽히는 대신 클래스를 멤버로
        만들어 감싼 클래스의 영역 안에 둔다. 중첩 클래스는 대개 구현에만
        연관되므로, 감싼 클래스의 선언에 중첩 클래스의 정의를 포함하지
        않기 위해 감싼 클래스 내에서 중첩 클래스를 전방 선언한 다음
        <code>.cc</code> 파일에서 중첩 클래스를 정의할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        중첩 클래스는 감싼 클래스의 정의 안에서만 전방 선언될 수 있다.
        그러므로 <code>Foo::Bar*</code> 포인터를 다루고자 하는 모든 헤더 파일은
        <code>Foo</code> 클래스의 전체 클래스 선언을 include해야 할 것이다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        중첩 클래스가 실제 인터페이스의 일부인 경우가 아니면 중첩 클래스를
        public으로 만들지 말라. 예를 들면 어떤 메서드의 옵션 세트를 담은
        클래스는 실제 인터페이스의 일부인 중첩 클래스이다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B9%84%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%95%EC%A0%81_%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%84%EC%97%AD_%ED%95%A8%EC%88%98" id="비멤버_함수,_정적_멤버_함수,_전역_함수">비멤버 함수, 정적 멤버 함수, 전역 함수</a></h3>
<span class="link_button" id="link-비멤버_함수,_정적_멤버_함수,_전역_함수__button" name="link-비멤버_함수,_정적_멤버_함수,_전역_함수__button"><a href="?showone=%EB%B9%84%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%95%EC%A0%81_%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%84%EC%97%AD_%ED%95%A8%EC%88%98#%EB%B9%84%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%95%EC%A0%81_%EB%A9%A4%EB%B2%84_%ED%95%A8%EC%88%98,_%EC%A0%84%EC%97%AD_%ED%95%A8%EC%88%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('비멤버_함수,_정적_멤버_함수,_전역_함수')" name="비멤버_함수,_정적_멤버_함수,_전역_함수__button" id="비멤버_함수,_정적_멤버_함수,_전역_함수__button">▶</span>
    <div style="display:inline;" class="">
      네임스페이스 안에 있는 비멤버 함수나 정적 멤버 함수를 전역 함수보다
      선호하라. 완전한 전역 함수는 가능하면 사용하지 말라.
    </div>
    <div class=""><div class="stylepoint_body" name="비멤버_함수,_정적_멤버_함수,_전역_함수__body" id="비멤버_함수,_정적_멤버_함수,_전역_함수__body" style="display: none">
      <p class="">
<span class="stylepoint_section">장점:  </span>
        비멤버 함수나 정적 멤버 함수는 때때로 유용할 수 있다. 비멤버 함수를
        네임스페이스에 두면 전체 영역 (전역) 네임스페이스을 더럽히지 않는다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        비멤버 함수나 정적 멤버 함수는 새 클래스의 멤버로 정의하는 것이 더
        합리적일 수 있다. 특히 그 함수들이 외부 리소스에 접근하는 경우나 상당한
        의존관계를 가진 경우 그렇다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          가끔은 함수를 클래스 인스턴스에 의존하지 않도록 정의하는 것이
          유용하고 때로는 필요하다. 이러한 함수들은 정적 멤버 함수이거나 비멤버
          함수일 수 있다. 비멤버 함수는 외부 변수에 의존적이어서는 안 되고, 거의
          항상 네임스페이스 안에 있어야 한다. 단순히 정적 데이터를 공유하지 않는 정적
          멤버 함수들을 분류하기 위해 새 클래스를 만들기 보다는
          <a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a>를 사용하라.
        </p>
        <p>
          생성된 클래스로서 같은 컴파일 단위에 정의된 함수들은 다른 컴파일
          단위에서 직접 호출될 때 불필요한 커플링이나 링크 시의 종속 관계를
          유발할 수 있다. 정적 멤버 함수가 여기에 특별히 민감하다. 이런 함수들을
          새 클래스로 뽑아 내거나, 아마 다른 라이브러리로 분리된 네임스페이스
          안에 이런 함수들을 두는 것을 고려하라.
        </p>
        <p>
          만약 비멤버 함수를 정의해야 하고 그것이 해당
          <code>.cc</code> 파일에서만 필요하다면, 그 인식 범위를 제한하기 위해
          이름 없는 <a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a>나
          <code>static</code> 링크(예로 <code>static int Foo() {...}</code>)를
          사용하라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A7%80%EC%97%AD_%EB%B3%80%EC%88%98" id="지역_변수">지역 변수</a></h3>
<span class="link_button" id="link-지역_변수__button" name="link-지역_변수__button"><a href="?showone=%EC%A7%80%EC%97%AD_%EB%B3%80%EC%88%98#%EC%A7%80%EC%97%AD_%EB%B3%80%EC%88%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('지역_변수')" name="지역_변수__button" id="지역_변수__button">▶</span>
    <div style="display:inline;" class="">
      함수의 변수는 가능한 한 좁은 범위에 두고, 선언에서 초기화하라.
    </div>
    <div class=""><div class="stylepoint_body" name="지역_변수__body" id="지역_변수__body" style="display: none">
      <p>
        C++에서는 함수 어디 곳에서나 변수 선언을 할 수 있지만, 변수를
        가능한 한 국한된 범위로 선언하고 최대한 첫 번째 사용처에 가깝게
        선언하기를 권장한다. 이는 읽는 사람이 선언을 찾고 변수의 타입과 초기값을
        알아내는 것을 쉽게 한다. 특히 선언과 대입 대신 초기화가 사용되어야
        한다. 예를 들자면
      </p>
      <div class=""><pre class="badcode">int i;
i = f();      // 나쁨 -- 초기화가 선언이 분리되어 있다.</pre></div>
      <div class=""><pre>int j = g();  // 좋음 -- 선언이 초기화를 가지고 있다.</pre></div>
      <div class=""><pre class="badcode">vector&lt;int&gt; v;
v.push_back(1);  // 중괄호 초기화를 사용하여 초기화하는 것을 선호하라.
v.push_back(2);</pre></div>
      <div class=""><pre>vector&lt;int&gt; v = {1, 2};  // 좋음 -- v는 시작부터 초기화된다.</pre></div>
      <p>
        gcc가 <code>for (int i = 0; i&lt; 10; ++i)</code>를 올바르게 구현하고
        있어서 (<code>i</code>의 범위는 오로지 <code>for</code> 반복문의 범위),
        같은 범위의 다른 <code>for</code> 반복문에서 <code>i</code>를 재사용할
        수 있다는 점에 주목하라. 또한 <code>if</code>와 <code>while</code> 안의
        선언의 범위도 올바르다. 예를 들면
      </p>
      <div class=""><pre>while (const char* p = strchr(str, '/')) str = p + 1;</pre></div>
      <p>
        경고할 것이 있다. 만약 변수가 객체이면 그 생성자는 범위에 들어가서 생성되는
        때마다 호출되고 그 소멸자는 범위를 빠져나갈 때마다 호출된다.
      </p>
      <div class=""><pre class="badcode">// 비효율적인 구현
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // 생성자와 소멸자는 각각 1000000회 호출된다.
  f.DoSomething(i);
}</pre></div>
      <p>
        반복문에서 사용되는 이런 변수를 선언할 때는 반복문 바깥에 하는 것이
        성능에 좋을 수 있다.
      </p>
      <div class=""><pre>Foo f;  // 생성자와 소멸자는 각각 한 번 호출된다.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%95%EC%A0%81_%EB%B3%80%EC%88%98%EC%99%80_%EC%A0%84%EC%97%AD_%EB%B3%80%EC%88%98" id="정적_변수와_전역_변수">정적 변수와 전역 변수</a></h3>
<span class="link_button" id="link-정적_변수와_전역_변수__button" name="link-정적_변수와_전역_변수__button"><a href="?showone=%EC%A0%95%EC%A0%81_%EB%B3%80%EC%88%98%EC%99%80_%EC%A0%84%EC%97%AD_%EB%B3%80%EC%88%98#%EC%A0%95%EC%A0%81_%EB%B3%80%EC%88%98%EC%99%80_%EC%A0%84%EC%97%AD_%EB%B3%80%EC%88%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('정적_변수와_전역_변수')" name="정적_변수와_전역_변수__button" id="정적_변수와_전역_변수__button">▶</span>
    <div style="display:inline;" class="">
      클래스 타입의 정적 변수와 전역 변수는 금지한다. 그것들은 특정할 수 없는
      생성과 소멸 순서로 인해 찾기 힘든 버그들을 만든다. 하지만 이들 변수가
      <code>constexpr</code>인 경우는 허용한다. 이들은 동적으로 초기화되거나
      소멸하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="정적_변수와_전역_변수__body" id="정적_변수와_전역_변수__body" style="display: none">
      <p>
        전역 변수, 정적 변수, 정적 클래스 멤버 변수, 함수 정적 변수 등의 정적
        저장 기간을 가진 객체들은 반드시 Plain Old Data (POD)여야 한다. 오직
        int, char, float, 포인터, 혹은 POD의 배열, POD의 구조체여야 한다.
      </p>
      <p>
        정적 변수의 클래스 생성자와 초기화 함수가 호출되는 순서는 C++에서
        부분적으로만 특정되어 있고, 심지어 각각의 빌드마다 호출 순서가 변경될 수
        있어 찾기 힘든 버그를 만들 수 있다. 그러므로 우리는 클래스 타입의 전역
        변수를 금지하며, 또한 (<code>getenv()</code>나
        <code>getpid()</code>처럼) 다른 전역 요소에 전적으로 의존하는 함수가
        아닌 한 함수를 사용하여 정적 POD 변수를 초기화할 수 없다.
      </p>
      <p>
        이와 비슷하게 전역 변수와 정적 변수는 <code>main()</code> 함수에서
        리턴하거나 <code>exit()</code>의 호출 여부에 무관하게 프로그램이
        종료될 때 소멸한다. 소멸자의 호출 순서는 생성자의 호출 순서의 반대로
        정의된다. 생성자의 호출 순서를 특정할 수 없기 때문에 소멸자의 호출
        순서도 마찬가지이다. 예를 들어 프로그램이 종료되는 시점에서 정적 변수는
        이미 소멸되었을 수 있고, 하지만 여전히 수행 중인 코드가 (아마도 다른
        스레드에 있는) 그것에 접근하려고 시도하고 실패할 수 있다. 혹은 어느 정적
        <code>string</code> 변수의 소멸자가 그 문자열을 참조하는 다른 변수에
        대한 소멸자보다 먼저 수행될 수도 있다.
      </p>
      <p>
        소멸자 문제를 완화하기 위해 <code>exit()</code> 대신
        <code>quick_exit()</code>을 불러 프로그램을 종료할 수도 있다.
        둘의 차이점은 <code>quick_exit()</code>는 소멸자를 호출하지 않으며
        <code>atexit()</code>를 호출하여 등록된 핸들러들을 호출하지 않는
        것이다. 만약 <code>quick_exit()</code>를 사용해서 프로그램을 종료할 때
        수행해야 하는 핸들러가 있는 경우 (예를 들면 로그를 flush 한다거나),
        <code>at_quick_exit()</code>를 사용하여 등록할 수 있다. (만약
        <code>exit()</code>와 <code>quick_exit()</code>에 모두 수행해야 하는
        핸들러가 있다면 두 곳 모두 등록해야 한다.)
      </p>
      <p>
        결과적으로 우리는 POD 데이터로 이루어진 가지는 정적 변수만을 허용한다. 이
        규칙은 <code>vector</code>(대신 C 배열을 사용하라)나
        <code>string</code>(대신 <code>const char []</code>를 사용하라)을
        완전히 금지한다.
      </p>

      <p>
        만약 클래스 타입의 정적 변수나 전역 변수가 필요하면
        <code>main()</code> 함수나 <code>pthread_once()</code>에서 (절대로
        해제되지 않는) 포인터를 초기화하는 방법을 고려하라. 이것은 "스마트"한
        포인터가 아닌 그냥 포인터여야 하는 데 주의하라. 스마트 포인터의 소멸자는
        우리가 피하려 하고 있는 소멸자 순서 문제를 야기할 것이기 때문이다.
      </p>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="클래스" id="클래스">클래스</h2>
  클래스는 C++ 코드에서 널리 사용하는 기본적인 단위이다.
  이 섹션은 클래스를 작성할 때 지켜야 할 것과 하지 말아야 할 것을 나열한다.
  <div class="">
<h3><a name="%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C%EC%9D%98_%EC%9E%91%EC%97%85" id="생성자에서의_작업">생성자에서의 작업</a></h3>
<span class="link_button" id="link-생성자에서의_작업__button" name="link-생성자에서의_작업__button"><a href="?showone=%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C%EC%9D%98_%EC%9E%91%EC%97%85#%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C%EC%9D%98_%EC%9E%91%EC%97%85">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('생성자에서의_작업')" name="생성자에서의_작업__button" id="생성자에서의_작업__button">▶</span>
    <div style="display:inline;" class="">
      생성자에서 복잡한 초기화 작업을 하는 것을 피하라 (특히 실패할 수 있는
      초기화나 가상 메서드 호출이 필요한 초기화).
    </div>
    <div class=""><div class="stylepoint_body" name="생성자에서의_작업__body" id="생성자에서의_작업__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        생성자의 본문에서 초기화를 할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        타이핑하기 편리함. 클래스가 초기화 되었는지 아닌지 신경 쓸 필요가 없음.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        생성자에서 작업을 할 때의 문제:
        </p><ul>
          <li> (<a href="#%EC%98%88%EC%99%B8">금지되어 있는</a>) 예외를 제외하고 생성자에서
               오류를 알릴 수 있는 쉬운 방법이 없다.
               </li>
          <li> 작업이 실패할 경우 초기화에 실패한 객체를 가지게 되고,
               이런 객체는 알 수 없는 상태일 수 있다.
               </li>
          <li> 생성자에서 가상 함수를 호출할 경우, 이 호출은 하위 클래스
               구현체에 전달되지 않을 것이다. 당장은 하위 클래스가 없더라도
               언젠가 클래스가 수정되면 이런 문제가 조용히 생겨날 수 있고
               이는 많은 혼동을 줄 것이다.
               </li>
          <li> 만약 누군가가 이 타입의 전역 변수를 만드는 경우 (이건 규칙
               위반이지만 그래도 하는 경우), 생성자 코드가
               <code>main()</code>보다 먼저 수행될 것이고, 아마도 생성자
               코드에 있는 암묵적인 가정을 깨뜨릴 것이다. 예를 들면
               <a href="http://google-gflags.googlecode.com/">gflags</a>들이
               아직 초기화되지 않았을 것이다.
               </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        생성자는 가상 함수를 부르거나 치명적이지 않은 실패를 알리려고 시도해서는
        절대 안 된다. 만약 어떤 객체가 사소하지 않은 초기화를 필요로 하면,
        팩토리 함수나 <code>Init()</code> 메서드의 사용을 고려하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%B4%88%EA%B8%B0%ED%99%94" id="초기화">초기화</a></h3>
<span class="link_button" id="link-초기화__button" name="link-초기화__button"><a href="?showone=%EC%B4%88%EA%B8%B0%ED%99%94#%EC%B4%88%EA%B8%B0%ED%99%94">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('초기화')" name="초기화__button" id="초기화__button">▶</span>
    <div style="display:inline;" class="">
      클래스의 멤버 변수를 정의할 때 반드시 모든 멤버 변수에
      대해 클래스 내 초기화 구문을 제공하거나 생성자를 작성해야 한다 (이는
      디폴트 생성자일 수 있다). 생성자를 직접 선언하지 않은 경우
      컴파일러는 일부 필드를 초기화되지 않은 채로 내버려 두거나 부적절한 값으로
      초기화시키는 디폴트 생성자를 만들 것이다.
    </div>
    <div class=""><div class="stylepoint_body" name="초기화__body" id="초기화__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        디폴트 생성자는 인자 없이 클래스 객체를 <code>new</code>했을 때
        호출된다. (배열의 경우에) <code>new[]</code>를 호출할 때 항상 호출된다.
        클래스 내 멤버 초기화란 <code>int count_;</code>나
        <code>string name_;</code>와 반대로 <code>int count_ = 17;</code>나
        <code>string name_{"abc"};</code>처럼 멤버 변수를 선언하면서
        구성하는 것을 뜻한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          초기화 구문이 제공되지 않았다면 사용자가 정의한 디폴트 생성자가 객체를
          초기화한다. 이는 객체가 항상 생성과 동시에
          유효하고 사용 가능한 상태임을 보장한다. 또한 디버깅을 지원하기 위해
          객체가 최초에는 명백하게 "성립불가능한" 상태로 생성되도록 보장한다.
        </p>
        <p>
          클래스 내 멤버 초기화는 여러 생성자에 초기화 코드를 중복해서 넣지
          않고도 멤버 변수가 적절히 초기화될 것을 보장한다. 이로써 새 멤버
          변수를 추가할 때 어떤 생성자에는 초기화 코드를 넣고, 다른 생성자에는
          초기화 코드를 넣지 않아서 생기는 버그가 줄어들 수 있다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
          디폴트 생성자를 명시적으로 정의하는 것은 코드 작성자에게
          추가적인 작업이다.
        </p>
        <p>
          멤버 변수가 선언 부분에서 초기화된 다음에 다시 생성자에서 초기화된
          경우, 생성자의 값이 선언의 값을 재정의하기 때문에 혼동을 줄 가능성이
          있다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          간단한 초기화에는, 특히 여러 생성자에서 같은 방식으로 초기화되는
          멤버 변수 같은 경우에는, 클래스 내 멤버 초기화를 사용하라.
        </p>
        <p>
          클래스의 멤버 변수가 클래스 내에서 초기화되지 않고 다른 생성자도 없는
          경우, 반드시 디폴트 생성자 (인자 없는 생성자)를 정의해야 한다.
          디폴트 생성자는 되도록 내부 상태가 일관성 있고 유효하도록
          객체를 초기화해야 한다.
        </p>
        <p>
          그 이유는 다른 생성자가 없는 상황에서 디폴트 생성자를 정의하지 않으면
          컴파일러가 디폴트 생성자를 만들어주기 때문이다. 컴파일러가 만든 생성자는
          객체를 올바르게 초기화하지 못할 수 있다.
        </p>
        <p>
          어떤 클래스가 기존 클래스를 상속했지만 새로운 멤버 변수를
          추가하지 않은 경우, 디폴트 생성자를 만들어야 할 필요는 없다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="explicit_%EC%83%9D%EC%84%B1%EC%9E%90" id="explicit_생성자">explicit 생성자</a></h3>
<span class="link_button" id="link-explicit_생성자__button" name="link-explicit_생성자__button"><a href="?showone=explicit_%EC%83%9D%EC%84%B1%EC%9E%90#explicit_%EC%83%9D%EC%84%B1%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('explicit_생성자')" name="explicit_생성자__button" id="explicit_생성자__button">▶</span>
    <div style="display:inline;" class="">
      인자가 하나인 생성자에는 C++ 키워드인 <code>explicit</code>을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="explicit_생성자__body" id="explicit_생성자__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        보통 생성자가 인자를 하나만 가지면 이 생성자는 변환에 사용될 수 있다.
        예를 들면 <code>Foo::Foo(string name)</code>을 정의하고
        <code>Foo</code>를 기대하는 함수에 문자열을 전달하면, 그 생성자가
        호출되어 문자열을 <code>Foo</code>로 바꾸고 그 <code>Foo</code>를 그
        함수에 전달하게 될 것이다. 이는 편리할 수 있지만 의도하지 않는 객체
        변환과 신규 객체 생성이 일어날 때는 골치거리이기도 하다. 생성자를
        <code>explicit</code>으로 선언하는 것은 생성자가 변환에 사용되기 위해
        암시적으로 호출되는 것을 막는다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        바람직하지 않은 변환을 예방.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        없음.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          인자가 하나인 모든 생성자는 <code>explicit</code>이어야 한다.
          인자가 하나인 생성자 정의의 앞에 항상 <code>explicit</code>를 포함하라.
          <code>explicit Foo(string name);</code>
        </p>
        <p>
          복사 생성자는 극히 일부 경우를 제외하고서는 반드시
          <code>explicit</code>이 아니어야 한다. 다른 클래스에 대한
          보이지 않는 래퍼(wrapper)로 의도된 클래스의 경우도 또 다른 예외이다.
          이런 예외들은 주석을 통해 명백하게 표시되어야 한다.
        </p>
        <p>
          마지막으로, 초기화 리스트(initializer_list) 하나만을 취하는 생성자들도
          explicit이 아닐 수 있다. 이는 중괄호 초기화 리스트들의 대입 형태를
          사용하여 타입을 생성하는 것을 허용하기 위함이다 (예를 들면
          <code>MyType m = {1, 2}</code> ).
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90" id="복사_생성자">복사 생성자</a></h3>
<span class="link_button" id="link-복사_생성자__button" name="link-복사_생성자__button"><a href="?showone=%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90#%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('복사_생성자')" name="복사_생성자__button" id="복사_생성자__button">▶</span>
    <div style="display:inline;" class="">
      필요한 경우 복사 생성자와 대입 연산자를 작성하라. 그 외에는
      <code>DISALLOW_COPY_AND_ASSIGN</code>로 그들을 쓸 수 없게 하라.
    </div>
    <div class=""><div class="stylepoint_body" name="복사_생성자__body" id="복사_생성자__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        복사 생성자와 대입 연산자는 객체의 복사본을 만들 때 쓰인다. 복사
        생성자는 어떤 상황에서 컴파일러에 의해 암시적으로 호출된다. (예를 들면
        객체를 값 전달(pass by value)하는 경우.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        복사 생성자를 사용하면 객체를 복사하는 것이 쉬워진다. STL 컨테이너는 모든
        구성 요소들이 복사 가능하고 할당 가능할 것을 요구한다. 생성과 복사가
        결합되어 있는 복사 생성자는 문맥에 따라 컴파일러가 생략할 수 있고
        힙(heap) 할당을 피하기 쉽게 하기 때문에, <code>CopyFrom()</code>
        스타일의 차선책보다 성능이 더 좋을 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        C++의 암시적 객체 복사는 버그와 성능 문제의 주 원인이다. 또한 값 전달은
        참조 전달(pass by reference)과 다르게 객체의 흐름을 추적하기 힘들고,
        그에 따라 객체의 변경이 어디에서 반영되었는지 추적하기 힘들어 가독성도 떨어진다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          복사 가능해야 하는 클래스는 거의 없다. 대부분의 클래스는 복사 생성자도
          대입 연산자도 가지지 말아야 한다. 많은 경우 값을 복사하는 대신 포인터나
          레퍼런스를 써서 더 나은 성능으로 같은 작업을 할 수 있다.
          예를 들면 함수 인자를 값 전달하는 대신 레퍼런스나 포인터로 전달할 수 있고,
          STL컨테이너에 객체를 저장하는 대신 포인터를 저장할 수 있다.
        </p>
        <p>
          만약 어떤 클래스가 복사 가능해야 한다면, 복사 생성자보다
          <code>CopyFrom()</code>이나 <code>Clone()</code>과 같이 암시적으로
          호출되지 않는 복사 메서드를 선호하라. 만약 복사 메서드로는 충분하지 않은
          상황이라면 (예를 들면 성능 상의 문제가 있다거나 클래스가 STL
          컨테이너가 값 전달될 필요가 있는 경우) 복사 생성자와
          대입 연산자를 둘 다 작성하라.
        </p>
        <p>
          복사생성자와 대입 연산자가 모두 필요 없는 경우 명시적으로 비활성화해야
          한다. 그러기 위해서 클래스의 <code>private:</code>
          부분에 기능 없는 복사 생성자와 대입 연산자의 선언을 추가하고 그에
          해당하는 정의를 제공하지 말라 (그러므로 이들을 사용하려고 시도하면
          링크 오류가 생긴다).
        </p>
        <p>
          편의상, <code>DISALLOW_COPY_AND_ASSIGN</code> 매크로를
          사용할 수 있다.
        </p>
        <div class=""><pre>// 복사 생성자와 = 연산자 함수를 금지하는 매크로
// 이는 클래스의 private: 선언 부분 안에서 사용되어야 한다.
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&amp;);               \
  void operator=(const TypeName&amp;)</pre></div>
        <p>
          그렇다면 클래스 <code>class Foo</code>에서,
        </p>
        <div class=""><pre>class Foo {
 public:
  Foo(int f);
  ~Foo();

 private:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};</pre></div>
        <p>
        </p>

      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9C%84%EC%9E%84%EA%B3%BC_%EC%83%9D%EC%84%B1%EC%9E%90_%EC%83%81%EC%86%8D" id="생성자_위임과_생성자_상속">생성자 위임과 생성자 상속</a></h3>
<span class="link_button" id="link-생성자_위임과_생성자_상속__button" name="link-생성자_위임과_생성자_상속__button"><a href="?showone=%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9C%84%EC%9E%84%EA%B3%BC_%EC%83%9D%EC%84%B1%EC%9E%90_%EC%83%81%EC%86%8D#%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9C%84%EC%9E%84%EA%B3%BC_%EC%83%9D%EC%84%B1%EC%9E%90_%EC%83%81%EC%86%8D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('생성자_위임과_생성자_상속')" name="생성자_위임과_생성자_상속__button" id="생성자_위임과_생성자_상속__button">▶</span>
    <div style="display:inline;" class="">
      코드 중복을 줄일 수 있다면 생성자 위임과 상속을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="생성자_위임과_생성자_상속__body" id="생성자_위임과_생성자_상속__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        </p><p>
          생성자 위임과 생성자 상속은 생성자의 코드 중복을 줄이기 위해 모두
          C++11에 도입된 기능으로 서로 다른 두 기능이다. 생성자 위임은 초기화
          리스트 문법을 통해 그 클래스의 한 생성자에서 다른 생성자로 작업을
          넘겨줄 수 있도록 한다. 예를 들면,
        </p>
        <div class=""><pre>X::X(const string&amp; name) : name_(name) {
  ...
}

X::X() : X("") { }</pre></div>
        <p>
          생성자 상속은 하위 클래스가 직접 사용 가능한 상위 클래스의 생성자를
          다시 선언하지 않고 마치 상위 클래스의 다른 멤버 함수처럼 가질 수
          있도록 한다. 이는 상위 클래스가 여러 생성자를 가진 경우에 특히
          유용하다. 예를 들면,
        </p>
        <div class=""><pre>class Base {
public:
  Base();
  Base(int n);
  Base(const string&amp; s);
  ...
};

class Derived : public Base {
public:
  using Base::Base;  // Base의 생성자는 여기서 재선언된다.
};</pre></div>
        <p>
          이는 <code>Derived</code>의 생성자가 <code>Base</code>의 생성자를
          호출하는 이외에 어떤 다른 일도 할 필요가 없을 때 특히 유용하다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          생성자 위임과 생성자 상속은 장황하고 획일적인 코드를 줄이고, 이는
          가독성을 개선한다.
        </p>
        <p>
          생성자 위임은 자바 프로그래머에게 친숙하다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
          핼퍼 함수를 사용함으로써 생성자 위임의 동작과 비슷한 것을 만들 수
          있다.
        </p>
        <p>
          하위 클래스가 새 멤버 변수를 도입한 경우 상위 클래스의
          생성자는 그들을 모르기 때문에 생성자 상속이 혼동을 줄 수 있다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          생성자 위임과 생성자 상속은 획일적인 코드를 줄이고 가독성을 개선할 수
          있는 경우에 사용하라. 만약 하위 클래스가 새 멤버 변수를 도입할 경우
          상속된 생성자들에 주의하라. 생성자 상속은 하위 클래스의 멤버
          변수가 클래스 내 멤버 초기화를 사용할 경우에도 적절할 수 있다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%8C%80_%ED%81%B4%EB%9E%98%EC%8A%A4" id="구조체_대_클래스">구조체 대 클래스</a></h3>
<span class="link_button" id="link-구조체_대_클래스__button" name="link-구조체_대_클래스__button"><a href="?showone=%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%8C%80_%ED%81%B4%EB%9E%98%EC%8A%A4#%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%8C%80_%ED%81%B4%EB%9E%98%EC%8A%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('구조체_대_클래스')" name="구조체_대_클래스__button" id="구조체_대_클래스__button">▶</span>
    <div style="display:inline;" class="">
      데이터를 나르는 수동적인 객체의 경우에만 <code>struct</code>를 사용하라.
      그 외의 모든 경우에는 <code>class</code>를 쓰라.
    </div>
    <div class=""><div class="stylepoint_body" name="구조체_대_클래스__body" id="구조체_대_클래스__body" style="display: none">
      <p>
        C++에서 <code>struct</code>와 <code>class</code> 키워드는 거의 똑같이
        동작한다. 여기서는 각각의 키워드에 고유한 의미를 부여한다. 그에 따라 
        정의하고자 하는 데이터 타입마다 적절한 키워드를 사용해야 한다.
      </p>
      <p>
        <code>structs</code>는 데이터를 나르는 수동적 객체로서 사용되고 연관된
        상수들을 포함할 수 있으나, 데이터 멤버의 값을 읽거나 쓰는 것
        이외의 어떤 기능도 가져서는 안 된다. 필드의 접근/변경은 메서드 호출이
        아닌 직접 필드에 접근하는 방식으로 이루어진다. 메서드는 데이터
        멤버를 셋업하는 것 외의 동작을 제공해서는 안 된다. 예를 들면 생성자,
        소멸자, <code>Initialize()</code>, <code>Reset()</code>,
        <code>Validate()</code>.
      </p>
      <p>
        만약 더 많은 기능이 필요하다면 <code>class</code>가 적당하다. 불확실한
        경우 <code>class</code>로 만들라.
      </p>
      <p>
        STL과의 일관성을 지키기 위해서, functor와 trait에 대해선
        <code>class</code> 대신 <code>struct</code>를 사용할 수 있다.
      </p>
      <p>
        구조체와 클래스의 멤버 변수들은
        <a href="#%EB%B3%80%EC%88%98_%EC%9D%B4%EB%A6%84">서로 다른 이름 규칙</a>을 가지는 데 주목하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%83%81%EC%86%8D" id="상속">상속</a></h3>
<span class="link_button" id="link-상속__button" name="link-상속__button"><a href="?showone=%EC%83%81%EC%86%8D#%EC%83%81%EC%86%8D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('상속')" name="상속__button" id="상속__button">▶</span>
    <div style="display:inline;" class="">
      컴포지션이 종종 상속보다 더 적절하다. 상속을 쓰려면
      <code>public</code>으로 하라.
    </div>
    <div class=""><div class="stylepoint_body" name="상속__body" id="상속__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        하위 클래스가 상위 클래스로부터 상속할 때, 하위 클래스는 부모인 상위
        클래스가 정의한 모든 데이터와 동작을 포함한다. C++에서 상속은
        주로 두 가지 실무적 용도로 사용된다. 실제 코드가 하위 클래스에 의해
        상속되는 구현 상속과 메서드 이름만 상속되는
        <a href="#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">인터페이스 상속</a>.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        구현 상속은 상위 클래스의 코드를 마치 현재 타입에 특화된 것처럼
        재사용함으로써 코드 크기를 줄인다. 상속은 컴파일시점의 선언이기 때문에,
        프로그래머와 컴파일러가 동작을 이해하고 오류를 찾을 수 있다. 인터페이스 상속은
        프로그래밍 측면에서 클래스가 특정 API를 노출하도록 강제할 때 사용될 수 있다.
        마찬가지로 컴파일러는 예를 들면 클래스가 API에 필요한 메서드를
        정의하지 않았다거나 하는 따위의 오류를 찾을 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        구현 상속의 경우 하위 클래스를 구현한 코드가 상위 클래스와 하위
        클래스에 흩어지기 때문에 구현을 이해하기가 더 어려울 수 있다. 하위
        클래스는 가상이 아닌 함수를 재정의할 수 없으므로, 하위 클래스는 구현을
        변경할 수 없다. 또한 상위 클래스가 일부 데이터 멤버를 정의해서 상위
        클래스의 물리적 레이아웃을 정해 버릴 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          모든 상속은 <code>public</code>이어야 한다. private 상속을
          사용하지 말고, 대신 상위 클래스의 인스턴스를 멤버로 포함시켜야 한다.
        </p>
        <p>
          구현 상속을 과용하지 말라. 대부분 컴포지션이 더 적절하다. 상속의
          사용을 "동일 관계"의 경우로 제한하려고 노력하라. <code>Bar</code>가
          <code>Foo</code>의 "종류 중 하나"라고 합당하게 말할 수 있으면
          <code>Bar</code>가 <code>Foo</code>의 하위 클래스이다.
        </p>
        <p>
          필요한 경우 소멸자를 <code>virtual</code>로 하라. 만약 클래스가
          가상 메서드를 가지고 있다면 그 소멸자는 반드시
          <code>virtual</code>이어야 한다.
        </p>
        <p>
          하위 클래스로부터 접근이 필요할 수 있는 멤버 함수들만
          <code>protected</code>로 선언하라.
          <a href="#%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4">데이터 멤버는 항상 private여야</a> 하는 데
          주의하라.
        </p>
        <p>
          상속받은 가상 함수를 재정의할 경우 명시적으로 하위 클래스의 선언에
          그것을 <code>virtual</code>로 선언하라. 그 이유는 만약
          <code>virtual</code>이 없으면 읽는 사람이 이 함수가 가상인지 아닌지
          궁금한 경우 이 클래스의 모든 조상을 확인해야 하기 때문이다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D" id="다중_상속">다중 상속</a></h3>
<span class="link_button" id="link-다중_상속__button" name="link-다중_상속__button"><a href="?showone=%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D#%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('다중_상속')" name="다중_상속__button" id="다중_상속__button">▶</span>
    <div style="display:inline;" class="">
      다중 구현 상속이 실제로 유용한 경우는 매우 드물다. 우리는 상위 클래스들 중
      최대 하나가 구현을 가진 경우에만 다중 상속을 허용한다. 다른 모든 상위
      클래스는 <code>Interface</code> 접미어가 달린
      <a href="#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">순수한 인터페이스 클래스</a>여야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="다중_상속__body" id="다중_상속__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        다중 상속은 하위 클래스가 하나 이상의 상위 클래스를 가지는 것을
        허용한다. 우리는 상위 클래스를 <em>순수한 인터페이스</em>인 것과
        <em>구현</em>을 가지고 있는 것으로 구분한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        다중 구현 상속은 단일 상속보다 더 많은 코드를 재사용하게 할 수 있다
        (<a href="#%EC%83%81%EC%86%8D">상속</a>을 보라).
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        다중 <em>구현</em> 상속이 실제로 유용한 경우는 매우 드물다. 다중 구현
        상속이 해법처럼 여겨질 경우라도, 보통은 더 명시적이고 깨끗한
        다른 방법을 찾을 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        다중 상속은 최대 하나의 예외를 제외하고는 모든 상위 클래스가 오직
        <a href="#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">순수한 인터페이스</a>일 때만 허용된다. 순수한
        인터페이스로 남아 있음을 보장하기 위해 이들은 <code>Interface</code>라는
        접미어로 끝나야 한다.
        </p><p class="">
<span class="stylepoint_subsection">주의:</span>
          윈도우에는 이 규칙의 <a href="#%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C">예외</a>가 하나 있다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" id="인터페이스">인터페이스</a></h3>
<span class="link_button" id="link-인터페이스__button" name="link-인터페이스__button"><a href="?showone=%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('인터페이스')" name="인터페이스__button" id="인터페이스__button">▶</span>
    <div style="display:inline;" class="">
      특정 조건을 만족하는 클래스만 <code>Interface</code>라는 접미어로 끝날
      수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="인터페이스__body" id="인터페이스__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        </p><p>
        아래와 같은 요구를 충족하는 클래스는 순수한 인터페이스이다.
        </p>
        <ul>
          <li> 오직 public 순수 가상 ("<code>= 0</code>") 메서드와 정적
               메서드만을 가진다 (단 소멸자의 경우는 아래를 보라).
               </li>
          <li> 정적이 아닌 데이터 멤버를 가질 수 없다.
               </li>
          <li> 생성자를 정의할 필요가 없다. 만약 생성자가 제공된다면
               인자가 없어야 하고 <code>protected</code>여야 한다.
               </li>
          <li> 하위 클래스의 경우, 오직 이와 같은 조건을 만족하며
               <code>Interface</code>라는 접미어로 표시된 클래스로부터
               상속받은 클래스여야 한다.
               </li>
        </ul>
        <p>
          인터페이스는 순수 가상 메서드를 포함하기 때문에 직접 인스턴스화될 수
          없다. 또한 해당 인터페이스의 모든 구현체가 바르게 소멸될 수 있는지 보장하기
          위해 인터페이스는 가상 소멸자를 반드시 정의해야 한다 (첫 번째
          규칙의 예외로 이 가상 소멸자가 순수할 필요는 없다). 자세한 내용은
          Stroustrup의 <cite>The C++ Programming Language</cite>, 3 판, 12.4
          섹션을 보라.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        클래스를 <code>Interface</code>라는 접미어로 표시하는 것은 다른 사람이
        이들에 구현이 있는 메서드나 정적이 아닌 데이터 멤버를 추가하면 안 된다는
        사실을 알게 한다. 이는 특히 <a href="#%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D">다중 상속</a>의 경우에
        특별히 중요하다. 또한 인터페이스 개념은 자바 프로그래머에게 이미 잘
        알려져 있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        <code>Interface</code> 접미어는 클래스 이름을 길게 늘여서 읽고 이해하기
        힘들게 만들 수 있다. 또한 인터페이스의 속성은 클라이언트에 노출되지
        말아야 할 구현 상세로 간주할 수도 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        위의 조건을 만족하는 경우에만 클래스는 <code>Interface</code>로 끝날 수
        있다. 하지만 반대의 경우가 필요한 것은 아니다. 즉, 위의 조건을 만족하는
        클래스가 꼭 <code>Interface</code>로 끝나야 하는 것은 아니다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%97%B0%EC%82%B0%EC%9E%90_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C" id="연산자_오버로드">연산자 오버로드</a></h3>
<span class="link_button" id="link-연산자_오버로드__button" name="link-연산자_오버로드__button"><a href="?showone=%EC%97%B0%EC%82%B0%EC%9E%90_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C#%EC%97%B0%EC%82%B0%EC%9E%90_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('연산자_오버로드')" name="연산자_오버로드__button" id="연산자_오버로드__button">▶</span>
    <div style="display:inline;" class="">
      흔치 않은 특별한 상황이 아니면 연산자를 오버로드하지 말라. 사용자가
      정의한 리터럴을 만들지 말라.
    </div>
    <div class=""><div class="stylepoint_body" name="연산자_오버로드__body" id="연산자_오버로드__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        클래스는 마치 내장 타입인 것처럼 클래스를 대상으로 동작하는
        <code>+</code>나 <code>/</code>와 같은 연산자를 정의할 수 있다.
        <code>operator""</code>를 오버로드하여 클래스 타입의 객체를 만드는 데
        내장 리터럴 문법을 사용할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          연산자 오버로드는 클래스가 내장 타입(<code>int</code> 따위)과 같은
          방식으로 동작하기 때문에 코드가 더 직관적으로 보이게 할 수 있다.
          오버로드된 연산자는 <code>Equals()</code>나 <code>Add()</code>와 같은
          단조로운 이름보다는 더 재미있는 함수 이름이다.
        </p>
        <p>
          어떤 템플릿 함수가 바르게 동작하기 위해 연산자를 정의해야 할 필요가
          있을 수 있다.
        </p>
        <p>
          사용자 정의 리터럴은 사용자 정의 타입의 객체를 생성하는 방법으로 매우
          간결한 표시법이다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        연산자 오버로드는 코드를 더 직관적으로 만들 수 있는 반면, 몇 가지 단점이
        있다.
        </p><ul>
          <li> 비싼 연산을 값이 싼 내장 연산으로 생각하도록 우리의 직관을 속일
               수 있다.
               </li>
          <li> 오버로드된 연산자가 호출된 장소를 찾는 것은 훨씬 어렵다.
               <code>Equals()</code>를 찾는 것은 이에 해당하는 <code>==</code>를
               찾는 것보다 훨씬 쉽다.
               </li>
          <li> 어떤 연산자는 포인터에서도 동작하는데, 버그를 만들기 쉽다.
               <code>Foo + 4</code>의 동작과 <code>&amp;Foo + 4</code>의 동작은
               완전히 다르다. 컴파일러는 어느 경우에도 문제삼지 않을 것이므로
               디버그는 아주 힘들어진다.
               </li>
          <li> 사용자 정의 리터럴은 숙련된 C++ 프로그래머조차도 생소한 문법을
               만들어 낼 수 있다.
               </li>
        </ul>
        또한 오버로드는 놀랄만 한 악영향을 끼친다. 예를 들어 클래스가 단항(unary)
        <code>operator&amp;</code>를 오버로드하면 그 클래스는 안전하게 전방
        선언될 수 없다.
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          일반적인 경우 연산자를 오버로드하지 말라. 특히 대입 연산자
          (<code>operator=</code>)는 위험하기 때문에 피해야 한다.
          필요한 경우 <code>Equals()</code>나 <code>CopyFrom()</code>과 같은
          함수를 정의할 수 있다. 마찬가지로, 전방 선언될 수 있는
          가능성이 조금이라도 어떻게 해서라도 위험한 단항
          <code>operator&amp;</code>도 피하라.
        </p>
        <p>
          <code>operator""</code>를 오버로드하지 말라. 즉, 사용자 정의
          리터럴을 도입하지 말라.
        </p>
        <p>
          그럼에도 템플릿이나 "표준" C++ 라이브러리 (로깅에 사용하는
          <code>operator&lt;&lt;(ostream&amp;, const T&amp;)</code> 따위)
          와 연동하기 위해 연산자를 오버로드해야 하는 드문 경우가 있을 수 있다.
          완벽히 정당화할 수 있는 경우 허용되지만, 가능한 매 순간마다 이를
          피하려고 노력해야 한다. 특히 어떤 클래스가 STL 컨테이너에 키로
          쓰일 수 있다는 이유만으로 <code>operator==</code>와
          <code>operator&lt;</code>를 오버로드하지 말라. 대신 컨테이너를 선언할
          때, 항등 functor와 비교 functor type을 만들어야 한다.
        </p>
        <p>
          어떤 STL 알고리즘은 <code>operator==</code>을 오버로드할 것을
          요구하는데, 이런 경우 그 이유를 설명으로 제공하면서 연산자를
          오버로드할 수 있다.
        </p>
        <p>
          <a href="#%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90">복사 생성자</a>와
          <a href="#%ED%95%A8%EC%88%98_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C">함수 오버로드</a>를 참조하라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4" id="접근_제어">접근 제어</a></h3>
<span class="link_button" id="link-접근_제어__button" name="link-접근_제어__button"><a href="?showone=%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4#%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('접근_제어')" name="접근_제어__button" id="접근_제어__button">▶</span>
    <div style="display:inline;" class="">
      데이터 멤버를 <code>private</code>으로 만들고, 필요한 경우 접근자 함수를
      통해 접근을 제공하라 (기술적인 이유로 우리는
      <a href="http://code.google.com/p/googletest/">Google Test</a>를 사용할 때
      test fixture 클래스의 데이터 멤버가 <code>protected</code>인 것을
      허용한다). <code>foo_</code>라고 불리는 변수가 있다면
      접근자 함수는 전형적으로 <code>foo()</code>라고 불린다. 또한
      <code>set_foo()</code>라는 변경자 함수가 필요할 수도 있다. 예외:
      <code>static const</code> 데이터 멤버(전형적으로 <code>kFoo</code>라고
      불리는)들은 <code>private</code>여야 할 필요가 없다.
    </div>
    <div class=""><div class="stylepoint_body" name="접근_제어__body" id="접근_제어__body" style="display: none">
      <p>
        보통 접근자의 정의는 헤더 파일에 인라인된다.
      </p>
      <p>
        <a href="#%EC%83%81%EC%86%8D">상속</a>과 <a href="#%ED%95%A8%EC%88%98_%EC%9D%B4%EB%A6%84">함수 이름</a>을
        참조하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%84%A0%EC%96%B8_%EC%88%9C%EC%84%9C" id="선언_순서">선언 순서</a></h3>
<span class="link_button" id="link-선언_순서__button" name="link-선언_순서__button"><a href="?showone=%EC%84%A0%EC%96%B8_%EC%88%9C%EC%84%9C#%EC%84%A0%EC%96%B8_%EC%88%9C%EC%84%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('선언_순서')" name="선언_순서__button" id="선언_순서__button">▶</span>
    <div style="display:inline;" class="">
      클래스 내의 선언에는 특별한 순서를 사용하라. <code>public:</code>이
      <code>private:</code>보다 먼저이며 메서드가 데이터 멤버 (변수)보다
      먼저이며, 기타 등등.
    </div>
    <div class=""><div class="stylepoint_body" name="선언_순서__body" id="선언_순서__body" style="display: none">
      <p>
        클래스 정의는 반드시 <code>public:</code> 부분으로 시작해야 하며, 그
        다음에 <code>protected:</code> 부분이 따라오고 그 다음이
        <code>private:</code> 부분이다. 만약 이 부분 중 비어 있는 것이 있다면,
        그 부분을 생략한다.
      </p>
      <p>
        각각의 부분 안에서 선언은 보통 아래와 같은 순서여야 한다.
      </p>
      <ul>
        <li> typedef들과 열거형</li>
        <li> 상수 (<code>static const</code> 데이터 멤버)</li>
        <li> 생성자</li>
        <li> 소멸자</li>
        <li> 정적 메서드를 포함한 모든 메서드</li>
        <li> 데이터 멤버 (단 <code>static const</code> 데이터 멤버는 제외)
        </li>
      </ul>
      <p>
        <code>friend</code> 선언은 항상 private 부분 안에 있어야 하고
        <code>DISALLOW_COPY_AND_ASSIGN</code> 매크로 호출은
        <code>private:</code> 부분의 마지막에 있어야 한며 클래스의
        마지막에 있는 것이어야 한다. <a href="#%EB%B3%B5%EC%82%AC_%EC%83%9D%EC%84%B1%EC%9E%90">복사 생성자</a>를
        참조하라.
      </p>
      <p>
        해당하는 <code>.cc</code> 파일의 메서드 정의는 가능한 한 선언과 같은
        순서여야 한다.
      </p>
      <p>
        클래스 정의에 너무 많은 인라인 메서드 정의를 넣지 말라. 보통 사소하거나
        성능에 중요한, 매우 짧은 메서드만이 인라인으로 정의될 수 있다.
        <a href="#%EC%9D%B8%EB%9D%BC%EC%9D%B8_%ED%95%A8%EC%88%98">인라인 함수</a>를 참조하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A7%A7%EC%9D%80_%ED%95%A8%EC%88%98%EB%A5%BC_%EC%93%B0%EA%B8%B0" id="짧은_함수를_쓰기">짧은 함수를 쓰기</a></h3>
<span class="link_button" id="link-짧은_함수를_쓰기__button" name="link-짧은_함수를_쓰기__button"><a href="?showone=%EC%A7%A7%EC%9D%80_%ED%95%A8%EC%88%98%EB%A5%BC_%EC%93%B0%EA%B8%B0#%EC%A7%A7%EC%9D%80_%ED%95%A8%EC%88%98%EB%A5%BC_%EC%93%B0%EA%B8%B0">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('짧은_함수를_쓰기')" name="짧은_함수를_쓰기__button" id="짧은_함수를_쓰기__button">▶</span>
    <div style="display:inline;" class="">
      짧고 집중된 함수를 선호하라.
    </div>
    <div class=""><div class="stylepoint_body" name="짧은_함수를_쓰기__body" id="짧은_함수를_쓰기__body" style="display: none">
      <p>
        가끔은 긴 함수가 적절하다는 것을 알고 있기 때문에 함수의 길이에
        관해 아주 강력한 제한을 두진 않는다. 만약 함수가 40 라인을 넘어가면
        프로그램의 구조를 해치지 않는 범위에서 이 함수를 나눌 수 있는지
        생각하라.
      </p>
      <p>
        만약 긴 함수가 지금은 완벽하게 동작하고 있다고 하더라도, 누군가
        몇 개월 후에 고쳐서 새로운 동작을 넣을 수 있다. 이로 인해 찾기 힘든 버그가
        발생할 수 있다. 함수를 짧고 간단하게 유지하는 것은 다른 사람이 코드를
        읽고 고치기 쉽게 한다.
      </p>
      <p>
        작업하다 보면 길고 복잡한 함수를 만날 수 있다. 기존의
        코드를 수정하는 데 두려움을 가지지 말라. 그런 함수에서 작업하는 것이
        어려운 경우 오류를 디버그하기 힘들어졌다고 깨닫게 되거나 함수가
        가진 여러 다른 맥락의 조각을 사용하고 싶어질 것인데 이 때 함수를 더
        작고 관리 가능한 조각으로 쪼개는 것을 고려하라.
      </p>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="구글만의_특별한_마법" id="구글만의_특별한_마법">구글만의 특별한 마법</h2>

  <p>
    다른 곳에서 본 것과 다를 수 있는, 구글에서 C++ 코드를 더 튼튼하게
    만들기 위해 사용하는 다양한 기법과 장치들이 있다.
  </p>
  <div class="">
<h3><a name="%EC%86%8C%EC%9C%A0%EA%B6%8C%EA%B3%BC_%EC%8A%A4%EB%A7%88%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0" id="소유권과_스마트_포인터">소유권과 스마트 포인터</a></h3>
<span class="link_button" id="link-소유권과_스마트_포인터__button" name="link-소유권과_스마트_포인터__button"><a href="?showone=%EC%86%8C%EC%9C%A0%EA%B6%8C%EA%B3%BC_%EC%8A%A4%EB%A7%88%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0#%EC%86%8C%EC%9C%A0%EA%B6%8C%EA%B3%BC_%EC%8A%A4%EB%A7%88%ED%8A%B8_%ED%8F%AC%EC%9D%B8%ED%84%B0">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('소유권과_스마트_포인터')" name="소유권과_스마트_포인터__button" id="소유권과_스마트_포인터__button">▶</span>
    <div style="display:inline;" class="">
      동적으로 할당된 객체들에는 하나의 고정된 소유자를 두는 것을 선호하라.
      스마트 포인터를 써서 소유권을 이전하는 것을 선호하라.
    </div>
    <div class=""><div class="stylepoint_body" name="소유권과_스마트_포인터__body" id="소유권과_스마트_포인터__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        </p><p>
          "소유권"이란 동적으로 할당된 메모리(와 다른 리소스)를 관리하는 기법이다.
          동적으로 할당된 객체의 소유자는 더 이상 필요치 않을 때 객체를 삭제할 것을
          보장하는 객체 또는 함수이다. 소유권은 종종
          공유될 수 있는데, 이 경우에는 보통 마지막 소유자가 삭제를 책임진다.
          공유되지 않는 경우에도 소유권은 코드의 한 곳의 코드에서
          다른 곳으로 이전될 수 있다.
        </p>
        <p>
          "스마트" 포인터는 포인터와 유사하게 동작하는 클래스로,
          <code>*</code>와 <code>-&gt;</code> 연산자를 오버로드하여 만든다.
          이러한 스마트 포인터 타입은 소유권 관리를 자동화하기 위해 사용될 수 있다.
          C++11에서 도입된 스마트 포인터 타입인
          <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
          <code>std::unique_ptr</code></a>는 동적으로 할당된 객체에 대한
          배타적인 소유권을 나타낸다.
          <code>std::unique_ptr</code>이 범위 밖으로 나갈 때 객체가 삭제되며,
          복사될 수는 없지만 소유권 이전에 해당하는 <em>이동</em>을 할 수 있다.
          <code>shared_ptr</code>은 복사가 가능한 것으로, 동적으로 할당된 객체에
          대한 공유된 소유권을 나타내는 스마트 포인터 타입이다. 객체의 소유권은
          모든 복사본에서 공유되며 객체는 마지막 <code>shared_ptr</code>가
          파괴될 때 삭제된다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><ul>
          <li>동적으로 할당되는 메모리를 어떤 종류의 소유권 로직 없이 관리하는
            것은 사실상 불가능하다.</li>
          <li>(복사가 가능한 경우라고 해도) 복사하는 것보다 객체의 소유권을
            이전하는 것이 성능 면에서 효율적일 수 있다.</li>
          <li>두 사용자 사이에서의 객체 수명주기를 조정할 필요를 줄여주기
            때문에, 소유권을 이전하는 것이 포인터나 레퍼런스를 "빌려오는" 것보다
            간단할 수 있다.</li>
          <li>스마트 포인터는 소유권 로직을 명시적이고 자기 기술적이며
            명료하게 만듦으로써 가독성을 향상시킬 수 있다.</li>
          <li>스마트 포인터는 소유권 관리를 자동으로 해 주기 때문에
            많은 종류의 오류를 없애고 코드를 단순화할 수 있다.</li>
          <li>const 객체들을 깊은 복사(deep copy)하는 것에 대한 대안으로 공유
            소유권이 간단하고 효율적일 수 있다.</li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><ul>
          <li>소유권은 (스마트이든 아니든) 포인터를 통해 표현되고 이전되어야
            한다. 포인터 문법은 값 문법(value semantics)보다 복잡하고,
            특히 API의 경우 소유권 뿐만 아니라 재명명, 수명 주기, 가변성 같은
            다른 이슈들도 고민해야 해서 더욱 복잡하다.</li>
          <li>값 문법(value semantics)의 성능상 비용은 생각보다 크지 않을
            수 있다. 소유권 이전으로 얻는 성능 향상을 위해 코드의 가독성과
            복잡성이 증가하는 것이 더 손해일 때도 있다.</li>
          <li>소유권을 이전하는 API는 클라이언트가 하나의 메모리 관리 모델을
            가지도록 강제한다.</li>
          <li>스마트 포인터를 사용하는 코드는 리소스를 해제하는 위치가 덜
            명시적이다.</li>
          <li>
<code>std::unique_ptr</code>는 소유권 이전을 C++11의 이동 문법으로
            표현하는 데, 이는 구글 코드에서
            <a href="#rvalue_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4">일반적으로 금지</a>된 것으로 몇몇
            프로그래머들에게는 혼란을 일으킬 수 있다.</li>
          <li>잘 설계된 소유권 관리 대신 공유 소유권을 사용하는 것이
            매력적으로 보이지만 도리어 시스템 설계를 어지럽힐 수 있다.</li>
          <li>공유 소유권으로 인해 런타임에 소유권 관리를 위한
            큰 비용이 필요할 수 있다.</li>
          <li>순환 참조를 비롯한 몇몇 경우에는 소유권이 공유된 객체들이
            영원히 삭제되지 않을 수 있다.</li>
          <li>스마트 포인터는 일반적인 포인터의 완전한 대용품이 아니다.</li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          동적 할당이 필요한 경우 할당한 코드에서 소유권을 유지하는 것을
          선호하라. 다른 코드가 그 객체를 접근해야 할 필요가 있는 경우
          소유권을 이전하기보다 복사본을 전달하거나 포인터 또는 레퍼런스를
          전달하는 것을 검토하라. 소유권 이전을 명시적으로 하기 위해
          <code>std::unique_ptr</code>를 사용하는 것을 선호하라. 예를 들면,
            </p><div class=""><pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);</pre></div>
        <p></p>
        <p>
          아주 좋은 근거가 없다면 공유 소유권을 쓰도록 코드를 디자인하지
          말라. 그러한 근거로 복사 작업의 비싼 비용을 피할 수 있다는 것을 들 수 있으나,
          기반 객체가 변경 불가능하며 성능상 이익이 상당한 경우에만 공유
          소유권을 사용해야 한다 (예를 들면
          <code>shared_ptr&lt;const Foo&gt;</code>).
          공유 소유권을 사용할 경우에는 <code>shared_ptr</code>의 사용을
          선호하라.
        </p>
        <p>
          구버전의 C++과 호환할 필요가 없는 새 코드에서는
          <code>scoped_ptr</code>을 사용하지 말라. <code>linked_ptr</code>이나
          <code>std::auto_ptr</code>을 절대 사용하지 말라. 위 세 가지 경우 모두
          <code>std::unique_ptr</code>을 대신 사용하라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="cpplint" id="cpplint">cpplint</a></h3>
<span class="link_button" id="link-cpplint__button" name="link-cpplint__button"><a href="?showone=cpplint#cpplint">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('cpplint')" name="cpplint__button" id="cpplint__button">▶</span>
    <div style="display:inline;" class="">
      스타일 오류를 찾기 위해 <code>cpplint.py</code>를 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="cpplint__body" id="cpplint__body" style="display: none">
      <p>
        <code>cpplint.py</code>는 소스 파일에 있는 여러 스타일 오류를 식별해 주는
        도구이다. 완벽하지 않고, 오류가 아닌 것을 오류로 판정하는 문제와 오류를
        식별하지 못하는 문제를 모두 가지고 있지만, 여전히 소중한 도구이다.
        <code>// NOLINT</code>를 라인 마지막에 넣으면 오류가 아닌 것을 오류로
        식별하는 문제를 무시하게 할 수 있다.
      </p>

      <p>
        어떤 프로젝트에는 프로젝트 툴에 <code>cpplint.py</code>를 실행하는 방법에 대한
        설명이 포함되어 있다. 그렇지 않은 프로젝트에선 따로 
        <a href="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py">
        <code>cpplint.py</code></a>를 다운로드받을 수 있다.
      </p>
    </div></div>
  </div>


</div>

<div class="">
<h2 name="그_외의_C++_기능" id="그_외의_C++_기능">그 외의 C++ 기능</h2>
  <div class="">
<h3><a name="%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%EC%9D%B8%EC%9E%90" id="레퍼런스_인자">레퍼런스 인자</a></h3>
<span class="link_button" id="link-레퍼런스_인자__button" name="link-레퍼런스_인자__button"><a href="?showone=%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%EC%9D%B8%EC%9E%90#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%EC%9D%B8%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('레퍼런스_인자')" name="레퍼런스_인자__button" id="레퍼런스_인자__button">▶</span>
    <div style="display:inline;" class="">
      레퍼런스로 전달되는 모든 인자는 <code>const</code>로 수식되어야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="레퍼런스_인자__body" id="레퍼런스_인자__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        C에서 함수가 변수를 변경할 필요가 있는 경우 인자는 포인터를 사용해야
        한다, 예를 들면 <code>int foo(int *pval)</code>. C++에서는 함수에서
        레퍼런스 인자를 선언할 수 있다. <code>int foo(int &amp;val)</code>
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        레퍼런스로 인자를 정의하는 것으로 <code>(*pval)++</code>과 같은 못생긴
        코드를 쓰지 않을 수 있으며, 복사생성자 등에서는 필수적으로 레퍼런스를
        써야 한다. 또 포인터와 달리 null 값을 가질 수 없는 것이 명확해진다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        레퍼런스는 포인터의 의미를 가지지만 값(value)과 같은 문법을 사용하므로
        혼란스러울 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          함수 인자 리스트에 안의 모든 레퍼런스는 <code>const</code>여야 한다.
        </p>
        <div class=""><pre>void Foo(const string &amp;in, string *out);</pre></div>
        <p>
          사실 구글 코드에는 입력 인자는 값(value)이거나 <code>const</code>
          레퍼런스고, 반면 출력 인자는 포인터라는 강력한 컨벤션이 있다. 입력
          인자는 <code>const</code> 포인터일 수 있지만, <code>swap()</code>처럼
          컨벤션으로 정해져 있는 경우를 제외하고는 <code>const</code>가 아닌
          레퍼런스 인자는 절대 허용하지 않는다.
        </p>
        <p>
          하지만 입력 인자에서 <code>const T&amp;</code>보다
          <code>const T*</code>를 사용하는 것이 나은 경우가 있다. 예를 들면,
          </p><ul>
            <li>null 포인터를 전달하고 싶다.</li>
            <li>함수가 입력에 대한 포인터나 레퍼런스를 저장한다.</li>
          </ul>
          대부분의 경우 입력 인자가 <code>const T&amp;</code>로 지정될 것이라는
          점을 기억하라. 그것 대신 <code>const T*</code>를 사용하면 입력이 다소 
          다르게 다루어질 것을 읽는 이가 알 수 있다. 그러므로
          만약 <code>const T&amp;</code> 대신 <code>const T*</code>를 택한다면
          분명한 이유가 있을 때여야 한다. 그렇게 하지 않으면 있지도 않는 설명을
          찾느라 읽는 사람이 혼란에 빠질 수 있다.
        <p></p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="rvalue_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4" id="rvalue_레퍼런스">rvalue 레퍼런스</a></h3>
<span class="link_button" id="link-rvalue_레퍼런스__button" name="link-rvalue_레퍼런스__button"><a href="?showone=rvalue_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4#rvalue_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('rvalue_레퍼런스')" name="rvalue_레퍼런스__button" id="rvalue_레퍼런스__button">▶</span>
    <div style="display:inline;" class="">
      rvalue 레퍼런스, <code>std::forward</code>,
      <code>std::move_iterator</code>, <code>std::move_if_noexcept</code>를
      사용하지 말라. 복사 불가능한 인자에 대해서만 단일 인자 형식의
      <code>std::move</code>를 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="rvalue_레퍼런스__body" id="rvalue_레퍼런스__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        rvalue 레퍼런스는 임시적인 개체에만 결합할 수 있는 레퍼런스의 종류이다.
        그 문법은 전통적인 레퍼런스 문법과 유사하다. 예를 들면,
        <code>void f(string&amp;&amp; s);</code>는 그 문자열의 rvalue 레퍼런스를
        인자로 취하는 함수를 선언한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><ul>
          <li>
            이동 생성자 (클래스 타입에 대한 rvalue 레퍼런스를 취하는 생성자)를
            정의하면 값을 복사하는 대신 이동시키는 것이 가능하다. 예를 들어
            <code>v1</code>이 <code>vector&lt;string&gt;</code>인 경우
            <code>auto v2(std::move(v1))</code>는 아마 커다란
            양의 데이터를 복사하는 대신 간단하게 포인터만 조작할 것이다. 이 경우
            성능이 크게 좋아질 수 있다.
          </li>
          <li>
            rvalue 레퍼런스는 인자를 다른 함수로 전달하는 범용
            함수 래퍼(wrapper)를 작성할 수 있게 하며, 그 인자들이 임시개체이든
            아니든 동작한다.
          </li>
          <li>
            rvalue 레퍼런스는 이동은 가능하나 복사가 불가능한 타입을 구현할 수
            있게 하며, 이는 복사의 적절한 정의는 없지만 함수 인자로 전달하거나
            컨테이너에 넣고 싶을 때 유용하다.
          </li>
          <li>
            <code>std::move</code>는 <code>std::unique_ptr</code> 등의 몇몇
            표준 라이브러리 타입을 효과적으로 사용하기 위해 필요하다.
          </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><ul>
          <li>rvalue 레퍼런스는 (C++11의 일부로 도입된) 상대적으로 새
            기능이므로, 아직 널리 이해되지 않았다. 참조 축소나 이동 생성자의
            자동화 문법과 같은 규칙은 복잡하다.
          </li>
          <li>rvalue 레퍼런스는 값 문법(value semantics)을 더 많이 사용하는
            프로그래밍 스타일을 장려한다. 이러한 스타일은 많은 개발자에게
            생소하고, 이들의 성능상 특징은 추론하기 힘들 수 있다.
          </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          rvalue 레퍼런스를 사용하지 말고, <code>std::forward</code>나
          (본질적으로 rvalue 레퍼런스 타입으로 형 변환하는 것에 불과한)
          <code>std::move_if_noexcept</code> 유틸리티 함수나
          <code>std::move_iterator</code>를 사용하지 말라. 복사 불가능한 개체
          (예를 들면 <code>std::unique_ptr</code>)에 대해서만, 혹은 복사
          불가능해 질 개체에 대한 템플릿 코드 안에서 단일 인자의
          <code>std::move</code>를 사용하라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C" id="함수_오버로드">함수 오버로드</a></h3>
<span class="link_button" id="link-함수_오버로드__button" name="link-함수_오버로드__button"><a href="?showone=%ED%95%A8%EC%88%98_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C#%ED%95%A8%EC%88%98_%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_오버로드')" name="함수_오버로드__button" id="함수_오버로드__button">▶</span>
    <div style="display:inline;" class="">
      읽는 사람이 호출부를 살펴볼 때, 굳이 어느 오버로드가 정확히
      호출되었는지 먼저 알아내지 않고도 무슨 일이 벌어졌는지 잘 파악할
      수 있는 경우에만 (생성자를 포함하여) 오버로드된 함수를 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_오버로드__body" id="함수_오버로드__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        </p><p>
          <code>const string&amp;</code>를 취하는 함수를 쓰고 그것을
          <code>const char*</code>를 취하는 다른 함수로 오버로드할 수 있다.
        </p>
        <div class=""><pre>class MyClass {
 public:
  void Analyze(const string &amp;text);
  void Analyze(const char *text, size_t textlen);
};</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        오버로드는 동일한 이름을 가진 함수가 다른 인자들을 취하도록 허용하여
        코드를 더 직관적으로 만들 수 있다. 템플릿화된 코드에서 필요할 수도
        있으며, 비지터에서 편리할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        함수가 인자의 타입으로만 오버로드된 경우, 어떤 일이 벌어지는지
        파악하려면 C++의 복잡한 매치 규칙을 이해해야 할 수 있다. 또한 하위
        클래스가 함수의 변형 중 일부만 재정의하는 경우, 상속 문법 때문에 많은
        사람들이 혼동할 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        함수를 오버로드하기를 원하면, 인자의 타입에 대한 정보로 이름을
        장식하는 것을 고려하라. 예를 들면 단순한 <code>Append()</code>보다
        <code>AppendString()</code>나 <code>AppendInt()</code>.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%94%94%ED%8F%B4%ED%8A%B8_%EC%9D%B8%EC%9E%90" id="디폴트_인자">디폴트 인자</a></h3>
<span class="link_button" id="link-디폴트_인자__button" name="link-디폴트_인자__button"><a href="?showone=%EB%94%94%ED%8F%B4%ED%8A%B8_%EC%9D%B8%EC%9E%90#%EB%94%94%ED%8F%B4%ED%8A%B8_%EC%9D%B8%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('디폴트_인자')" name="디폴트_인자__button" id="디폴트_인자__button">▶</span>
    <div style="display:inline;" class="">
      아래에 설명된 제한된 상황을 제외하고는 디폴트 함수 인자는 허용하지 않는다.
      그 대신 적절하다면 함수 오버로딩을 고려하라.
    </div>
    <div class=""><div class="stylepoint_body" name="디폴트_인자__body" id="디폴트_인자__body" style="display: none">
      <p class="">
<span class="stylepoint_section">장점:  </span>
        함수가 대부분의 경우 어떤 값을 디폴트로 사용하지만 때때로 다른 값을
        사용하게 하고 싶은 경우가 있다. 이러한 흔치 않은 예외를 위한 함수들을 
        많이 정의하지 않고도 이를 할 수 있는 쉬운 방법이 디폴트 인자이다. 
        디폴트 인자는 함수 오버로딩에 비해 더 명확한 문법이고 반복 코드가 
        적게 발생하며 '필요한' 인자와 '선택적' 인자를 더 분명하게 구분한다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        디폴트 인자가 있으면 함수 포인터 사용이 혼란스럽다. 함수 시그너처와
        호출 시그너처가 자주 맞지 않기 때문이다. 이미 존재하는 함수에
        디폴트 인자를 추가하는 것은 함수의 타입을 변경하며,
        해당 함수의 주소를 받는 코드에 문제가 될 수 있다. 함수 오버로드를
        추가하여 이런 문제들을 피할 수 있다. 게다가, 오버로드된 함수가 그
        정의에만 기본값이 포함되는 반면 디폴트 인자는 모든 호출지점으로
        복제되기 때문에 코드가 비대해질 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          위의 단점이 그렇게 부담이 되는 것은 아니지만, 여전히 함수 오버로딩에
          비한 디폴트 인자의 (작은)장점보다 단점이 크다. 그래서
          아래에 기술된 것을 제외하고는 모든 인자는 명시적으로 지정되어야
          한다.
        </p>
        <p>
          다른 명시적인 예외는 .cc 파일에서의 정적 함수(혹은
          이름 없는 네임스페이스 안의 함수)이다. 이런 경우,
          함수의 사용이 지역적이기 때문에 단점이 적용되지 않는다.
        </p>
        <p>
          또다른 명시적인 예외는 디폴트 인자가 가변길이 인자 목록 리스트로
          쓰여질 때이다.
        </p>
        <div class=""><pre>// Support up to 4 params by using a default empty AlphaNum.
string StrCat(const AlphaNum &amp;a,
              const AlphaNum &amp;b = gEmptyAlphaNum,
              const AlphaNum &amp;c = gEmptyAlphaNum,
              const AlphaNum &amp;d = gEmptyAlphaNum);</pre></div>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EA%B0%80%EB%B3%80%EA%B8%B8%EC%9D%B4_%EB%B0%B0%EC%97%B4%EA%B3%BC_alloca__" id="가변길이_배열과_alloca__">가변길이 배열과 alloca()</a></h3>
<span class="link_button" id="link-가변길이_배열과_alloca____button" name="link-가변길이_배열과_alloca____button"><a href="?showone=%EA%B0%80%EB%B3%80%EA%B8%B8%EC%9D%B4_%EB%B0%B0%EC%97%B4%EA%B3%BC_alloca__#%EA%B0%80%EB%B3%80%EA%B8%B8%EC%9D%B4_%EB%B0%B0%EC%97%B4%EA%B3%BC_alloca__">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('가변길이_배열과_alloca__')" name="가변길이_배열과_alloca____button" id="가변길이_배열과_alloca____button">▶</span>
    <div style="display:inline;" class="">
      가변길이 배열이나 <code>alloca()</code>를 허용하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="가변길이_배열과_alloca____body" id="가변길이_배열과_alloca____body" style="display: none">
      <p class="">
<span class="stylepoint_section">장점:  </span>
        가변길이 배열은 자연스러운 문법이다. 가변길이 배열과
        <code>alloca()</code> 는 매우 효율적이다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        가변길이 배열과 alloca 는 C++ 표준이 아니다.
        게다가, 할당되는 스택의 크기가 데이터에 의존적이라서 찾기 어려운 메모리
        덮어쓰기 버그를 만들 수도 있다. "나의 머신에서는 잘 작동하였는데,
        릴리즈되면 이상하게도 죽어버린다"
      </p>

      <p class="">
<span class="stylepoint_section">결론:  </span>
        <code>scoped_ptr</code>/<code>scoped_array</code> 같은 안전한 할당자를
        사용하여라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="Friends" id="Friends">Friends</a></h3>
<span class="link_button" id="link-Friends__button" name="link-Friends__button"><a href="?showone=Friends#Friends">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('Friends')" name="Friends__button" id="Friends__button">▶</span>
    <div style="display:inline;" class="">
      합당한 선에서 <code>friend</code> 클래스와 함수들을 사용한다.
    </div>
    <div class=""><div class="stylepoint_body" name="Friends__body" id="Friends__body" style="display: none">
      <p>
        <code>friend</code>는 코드를 읽는 이가 클래스의 private 멤버의 사용을
        다른 파일에서 확인할 필요가 없도록 하기 위해서 일반적으로
        같은 파일에서 정의된다. <code>friend</code>의 일반적인
        용례는 <code>Foo</code> 클래스의 내부 상태를 외부에 노출시키지 않고
        제대로 구성하기 위해 <code>FooBuilder</code> 클래스가 <code>Foo</code>
        클래스의 <code>friend</code>가 되는 것이다. 유닛테스트 클래스를 테스트
        대상 클래스의 <code>friend</code>로 만드는 것이 때때로 유용하다.
      </p>
      <p>
        <code>friend</code>는 클래스의 캡슐화의 경계를 확장하지만 깨뜨리지는
        않는다. 이것은 다른 클래스 하나를 위해 멤버를 public으로
        두는 것보다 낫다. 그러나 대부분의 클래스는 public 멤버들을
        통해서만 다른 클래스들과 상호작용하여야 한다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%98%88%EC%99%B8" id="예외">예외</a></h3>
<span class="link_button" id="link-예외__button" name="link-예외__button"><a href="?showone=%EC%98%88%EC%99%B8#%EC%98%88%EC%99%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('예외')" name="예외__button" id="예외__button">▶</span>
    <div style="display:inline;" class="">
      C++ 예외를 사용하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="예외__body" id="예외__body" style="display: none">
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><ul>
          <li>예외를 사용하면 코드를 더럽히거나 에러코드를 기록하지 않고도 
            깊게 중첩된 함수에서 일어나선 안 되는 오류를 다루는 법을 
            응용 코드에서 결정할 수 있다.</li>

          <li>예외는 대부분의 다른 현대 언어들에서 사용된다.
            C++ 에서 예외를 사용하는 것은 사람들에게 친숙한 파이썬, 자바, C++ 과
            더 일관성 있게 만든다.</li>

          <li>몇몇 서드파티 C++ 라이브러리들은 예외를 사용하고,
            내부적으로 예외를 사용하지 않는 것은 이런 라이브러리들과의
            통합을 어렵게 만든다.</li>

          <li>예외는 생성자가 실패처리를 할 수 있는 유일한
            방법이다. 이것을 팩토리 함수나 <code>Init()</code>
            메서드로 흉내낼 수 있지만, 이런 방법들은 각각 힙 할당과
            "유효하지 않은 상태"의 도입을 필요로 한다.</li>

          <li>예외는 테스트 프레임워크에서 정말 편리하다.</li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><ul>
          <li>기존의 함수에 <code>throw</code> 문을 추가할 때 그 함수를 
            직간접적으로 호출하는 모든 부분을 반드시 확인해야 한다. 함수는 최소한의
            기본 예외안전을 보장해야 하며, 그렇지 않다면 아예 예외를 받지 않아서
            프로그램이 잘 종료되도록 해야 한다. 예를 들어 <code>f()</code>가
            <code>g()</code>를, <code>g()</code>가 <code>h()</code>를 호출하되
            <code>h</code>가 던지는 예외를 <code>f</code>가 받는다고 할 때,
            <code>g</code>는 주의 깊게 작성되어야 하며 그렇지 않으면 리소스가
            제대로 정리되지 못할 수 있다.</li>

          <li>더 일반적으로, 예외는 코드를 보며 프로그램의 흐름을 파악하기
            어렵게 하고 함수들이 어디서 제대로 리턴할 지 기대하기 어렵게
            만들며 이것은 유지 보수와 디버깅을 어렵게 한다. 이러한 불편은 어디서
            어떻게 예외를 사용할지 규칙을 정하는 것으로 줄일 수 있지만
            개발자가 그것을 알고 이해해야 한다는 비용도 크다.</li>

          <li>예외 안정성을 위해 RAII 및 다른 코딩 관습들이 필요하다. 예외에
            안전한 코드를 정확하고 알기 쉽게 작성하려면 많은 지원장치들이 필요하다.
            또한 코드를 읽는 이가 전체 호출 그래프를 이해하지 않아도 되게 하려면,
            예외에 안전한 코드는 영속적인 상태를 변경하는 코드를 "커밋" 단계로
            분리해야 한다. 이것에는 장단점이 존재한다. (아마도
            커밋 단계를 분리하기 위해 코드를 꼬아야 할 것이다.) 예외를
            허용하는 것이 그만한 가치가 없을지라도 이런 비용들을 지불해야 할
            것이다.</li>

          <li>예외를 사용하는 것은 만들어진 각 바이너리(binary)에 데이터를
            추가하고 (아마도 작겠지만) 컴파일 시간과 주소 공간의 부담을
            증가시킨다.</li>

          <li>예외사용이 가능하다면, 개발자는 적절치 않은 예외를 던지거나,
            안전하지 않은 복구를 하게될 수도 있다. 예를 들어, 유효하지 않은
            사용자 입력은 예외를 발생시키지 않아야 한다. 이런 제약조건을
            추가하다 보면 이 문서가 더 길어질 것이다.</li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
           어떤 면에서, 특히 새 프로젝트에서 예외를 쓰는 경우 비용보다 이득이
           많다. 그러나 기존의 코드에서 예외를 사용하기 시작하는 것은
           모든 의존적인 코드에 영향을 미친다. 만약 예외가 새로운 프로젝트를
           넘어서 전파될 수 있다면, 새로운 프로젝트를 예외를 사용하지 않는
           기존코드에 통합하는 것이 문제가 된다. 구글에서의 대부분의 기존 C++
           코드는 예외를 다룰 준비가 안되어 있기 때문에, 예외를 만드는 새로운
           코드를 적용하는 것은 상대적으로 어렵다.
        </p>
        <p>
          구글의 기존 코드가 예외에 내성이 없다는 점을 감안하면, 예외를 사용하는
          비용은 새로운 프로젝트에서의 비용보다 다소 크다. 전환 작업은 느리고
          에러의 소지가 클 것이다. 에러코드 및 assert처럼 예외 대신 쓸 수 있는
          것들이 크게 부담될 것이라 생각되지 않는다.
        </p>
        <p>
          예외를 쓰지 말라는 충고는 철학적·윤리적인 배경이 아니라 실질적인
          이유에 기반한다. 우리는 구글의 오픈소스 프로젝트들을 사용하기를
          원하는데, 이런 프로젝트들이 예외를 사용한다면 그렇게 하는 것이 어렵기
          때문에 구글의 오픈소스 프로젝트들 또한 예외를 사용하지 않기를 권한다.
          처음부터 예외를 전체적으로 사용하기로 했었다면 아마 상황이 다를
          것이다.
        </p>
        <p>
          이 제한은 또한 <code>noexcept</code>, <code>std::exception_ptr</code>,
          <code>std::nested_exception</code> 처럼 C++11 에서 추가된 예외에
          관련된 기능들에도 적용된다.
        </p>
        <p>
          윈도우 코드에는 이 규칙의 <a href="#%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C">예외사항</a>이 있다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="Run-Time_Type_Information__RTTI_" id="Run-Time_Type_Information__RTTI_">Run-Time Type Information (RTTI)</a></h3>
<span class="link_button" id="link-Run-Time_Type_Information__RTTI___button" name="link-Run-Time_Type_Information__RTTI___button"><a href="?showone=Run-Time_Type_Information__RTTI_#Run-Time_Type_Information__RTTI_">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('Run-Time_Type_Information__RTTI_')" name="Run-Time_Type_Information__RTTI___button" id="Run-Time_Type_Information__RTTI___button">▶</span>
    <div style="display:inline;" class="">
      Run Time Type Information (RTTI)의 사용을 피한다.
    </div>
    <div class=""><div class="stylepoint_body" name="Run-Time_Type_Information__RTTI___body" id="Run-Time_Type_Information__RTTI___body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        프로그래머는 RTTI를 통해 객체의 C++ 클래스를 실행시간(run-time)에
        질의할 수 있다.
        이것은 <code>typeid</code>나 <code>dynamic_cast</code>를 통해서
        이루어진다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
         실행시간(run-time)에 객체의 타입을 자주 질의하는 것은 설계에 문제가
         있다는 뜻이다. 실행시간에 객체의 타입을 알아야 하는 것은 클래스
         계층 설계가 가진 결함의 징후인 경우가 종종 있다.
        </p>
        <p>
         RTTI 의 무분별한 사용은 코드를 유지보수하기 어렵게 만든다. 그리고 타입
         기반의 의사 결정 트리나 코드에 흩어져있는 <code>switch</code> 문을
         만든다. 이런 모든 것들은 나중에 코드를 변경할 때 반드시 검사되어야
         한다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          아래에 기술된 RTTI의 표준적인 대안을 적용하려면 해당 클래스의 계층을
          변경하거나 재설계해야 한다. 가끔 이런 변경은 불가능하거나 바람직하지
          않으며, 특히 널리 사용되거나 원숙한 코드에서 더욱 그렇다.
        </p>
        <p>
          RTTI는 몇몇 유닛테스트들에서 유용하다. 예를 들어, 팩토리 클래스에서
          새롭게 만들어진 객체가 기대한 동적 타입을 가지는지 검증하는 테스트에서
          유용하다. 또한 객체들과 그들의 모형(mock)간의 관계를 관리하는데
          유용하다.
        </p>
        <p>
          RTTI는 여러 개의 추상 객체들을 고려할 때 유용하다. 
          아래와 같은 방법을 고려하라.

          </p><div class=""><pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == NULL)
    return false;
  ...
}</pre></div>
        <p></p>

      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          RTTI 는 적법하지만 남용될 수 있으므로 반드시 주의깊게 사용해야 한다.
          유닛테스트에서는 자유롭게 사용해도 되지만, 다른 코드에서는 가능하면
          피하라. 특히 새로운 코드에서 RTTI를 사용할 때는 다시 한 번 생각하라.
          만약 객체의 클래스에 따라 다르게 거동하는 코드를 작성할 필요가 있다면,
          타입을 질의하는 아래의 대안 중 하나를 고려하라.
        </p><ul>
          <li>
            가상 메서드는 하위 클래스 타입에 따라 다른 코드 경로로 실행하려 할
            때 선호되는 방법이다. 이것은 작업을 객체 스스로가 처리하게 한다.
          </li>
          <li>
            만약 작업이 객체의 밖에 있는 처리코드에서 일어난다면
            비지터 설계 패턴 같은 이중 디스패치를 고려하라.
            이것은 객체 자신의 바깥에서 내장 타입 시스템을 이용하여 클래스의
            타입을 결정할 수 있게 한다.
          </li>
        </ul>
        <p></p>
        <p>
          프로그램의 로직에서 어떤 상위 클래스의 인스턴스가 특정 하위 클래스의
          인스턴스라는 것을 보장한다면, <code>dynamic_cast</code> 는 그 객체에
          대해 자유롭게 사용할 수 있다.
          일반적으로 그런 상황에서 <code>static_cast</code>를 대신 사용할 수
          있다.
        </p>
        <p>
          타입을 기반으로 한 결정 트리는 코드가 잘못되고 있다는 징후이다.

          </p><div class=""><pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...</pre></div>
          위와 같은 코드는 추가적인 하위 클래스들이 클래스 계층에 추가될 때
          일반적으로 문제가 된다. 게다가 하위 클래스의 속성이 변경될 때 영향받는
          모든 코드 조각들을 찾아 수정하는 일은 어렵다.
        <p></p>
        <p>
          RTTI 와 비슷한 회피 방법을 직접 구현하지 말라. RTTI 에 대한 논의는
          타입 태그를 이용한 클래스 계층같은 회피 방법들에도 반드시 적용된다.
          게다가, 회피 방법들은 실제 의도를 감춘다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%98%95_%EB%B3%80%ED%99%98" id="형_변환">형 변환</a></h3>
<span class="link_button" id="link-형_변환__button" name="link-형_변환__button"><a href="?showone=%ED%98%95_%EB%B3%80%ED%99%98#%ED%98%95_%EB%B3%80%ED%99%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('형_변환')" name="형_변환__button" id="형_변환__button">▶</span>
    <div style="display:inline;" class="">
      <code>static_cast&lt;&gt;()</code> 같은 C++ 형 변환을 사용하라.
      <code>int y = (int)x;</code> 나 <code>int y = int(x);</code> 같은
      다른 형 변환 형식을 사용하지 말라.
    </div>
    <div class=""><div class="stylepoint_body" name="형_변환__body" id="형_변환__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        C++은 C와는 달리 형 변환의 타입을 구별하는 시스템을 도입하였다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        C 형 변환의 문제점은 연산이 모호하다는 것이다.
        가끔은 (<code>(int)3.5</code>와 같은) <em>conversion</em> 을 하고
        가끔은 (<code>(int)"hello"</code>와 같은) <em>cast</em> 을 한다.
        C++ 형 변환은 이것을 방지한다. 게다가 C++ 형 변환은 검색하기도
        좋다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        문법이 못생겼다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          C 스타일의 형 변환을 사용하지 말라. 대신에 C++ 스타일의 형 변환을
          사용하라.
        </p>
        <ul>

          <li> C 스타일 형 변환이 하는 값 변환에 대응되는 경우거나, 클래스의
               포인터를 명시적으로 상위클래스로 업-캐스트(up-cast)를 할 때
               <code>static_cast</code>를 사용하라.
               </li>
          <li> <code>const</code> 수식어를 제거하기 위해서
               <code>const_cast</code> 를 사용하라.
               (<a href="#const%EC%9D%98_%EC%82%AC%EC%9A%A9">const</a> 참조)
               </li>

          <li> 포인터 타입을 정수 및 다른 포인터 타입과 안전하지 않게 서로
               형 변환할 때 <code>reinterpret_cast</code>를 사용하라.
               지금 무엇을 하고 있는지 알고 있으며
               aliasing 문제를 이해할 때에만 이것을 사용하라.
               </li>
        </ul>
        <p> <code>dynamic_cast</code>의 사용지침은
            <a href="#Run-Time_Type_Information__RTTI_">RTTI</a> 를 참조하라.
            </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%8A%A4%ED%8A%B8%EB%A6%BC" id="스트림">스트림</a></h3>
<span class="link_button" id="link-스트림__button" name="link-스트림__button"><a href="?showone=%EC%8A%A4%ED%8A%B8%EB%A6%BC#%EC%8A%A4%ED%8A%B8%EB%A6%BC">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('스트림')" name="스트림__button" id="스트림__button">▶</span>
    <div style="display:inline;" class="">
      로그를 위해서만 스트림을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="스트림__body" id="스트림__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        스트림은 <code>printf()</code> 과 <code>scanf()</code> 를 대체한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        스트림을 사용하면 출력하려는 객체의 타입을 알 필요가 없고
        인자 리스트와 포맷 문자열이 일치하지 않는 문제가 없다.
        (gcc를 사용하는 경우 <code>printf</code>도 그런 문제가 없다.)
        스트림은 연관된 파일들을 열고 닫는 자동적인
        생성자와 소멸자를 가진다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        스트림에서는 <code>pread()</code> 같은 기능을 만들기 어렵다.
        특히, <code>%.*s</code>와 같은 문자열 포매팅은 <code>printf</code>와
        비슷한 교묘한 방법(hack)없이 스트림으로 효과적으로 처리하기가
        불가능하거나 어렵다. 스트림은 국제화에 유용한 (<code>%1s</code> 지시자
        같은) 연산자 재정렬을 지원하지 않는다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>

        </p><p>
          로그를 위한 인터페이스에 필요할 때가 아니면 스트림을 사용하지 말라.
          대신 <code>printf</code>같은 것들을 사용하라.
        </p>
        <p>
          스트림을 사용하는 데 다양한 장단점들이 있지만, 다른 많은
          경우들과 같이 논의보다 일관성이 중요하다. 코드에서 스트림을 쓰지 말라.
        </p>

        <p class="">
<span class="stylepoint_subsection">추가 논의</span>
          </p><p>
            이 문제에 대해서 논쟁이 있어 왔다. 그래서 좀 더 깊게 이유를
            설명하겠다. "단 하나의 방법 가이드 원칙"을 기억하자. 우리는,
            어떤 형태의 I/O 를 할 때, 모든 곳에서 같은 형태의 코드를 보길
            원한다. 이 때문에 사용자가 스트림이나 <code>printf</code>와
            <code>read</code>/<code>write</code> 중 하나를 선택하는 것을
            허용하고 싶지 않았다. 대신 우리는 이것이나 저것 중 하나로 정해야
            했다. 로그는 꽤 특화된 어플리케이션이고 역사적인 이유가 있기에
            예외로 하였다.
          </p>
          <p>
            스트림의 추종자들은 둘 중 스트림이 명백히 낫다고 주장하지만, 사실
            이 문제는 그리 명백하지 않다. 그들이 지적하는 스트림의 모든 장점들은
            동등한 단점을 가지고 있다. 가장 큰 장점은 출력할 객체의 타입을
            몰라도 된다는 점이다. 이것은 타당하다. 하지만 잘못된 타입을 쉽게
            사용할 수 있고, 컴파일러가 경고를 하지 않는다는 단점도 있다.
            스트림을 사용할 때 자신도 모르게 이런 종류의 실수를 만들기 쉽다.
          </p>
          <div class=""><pre>cout &lt;&lt; this;  // 주소를 출력하라
cout &lt;&lt; *this;  // 내용을 출력하라</pre></div>
          <p>
            <code>&lt;&lt;</code> 가 오버로드되었기 때문에, 컴파일러는
            오류를 내지 않는다. 정확히 이런 이유로 오버로드를 권하지
            않는다.
          </p>
          <p>
            누군가는 <code>printf</code> 포맷팅이 못생기고 읽기 어렵다고 하지만,
            스트림도 더 나을 것이 없다. 아래 코드를 보자. 둘다 오타가 있다.
            어느 것이 더 발견하기 쉬운가?
          </p>
          <div class=""><pre>cerr &lt;&lt; "Error connecting to '" &lt;&lt; foo-&gt;bar()-&gt;hostname.first
     &lt;&lt; ":" &lt;&lt; foo-&gt;bar()-&gt;hostname.second &lt;&lt; ": " &lt;&lt; strerror(errno);

fprintf(stderr, "Error connecting to '%s:%u: %s",
        foo-&gt;bar()-&gt;hostname.first, foo-&gt;bar()-&gt;hostname.second,
        strerror(errno));</pre></div>
          <p>
            추가적인 논쟁이 계속 나올 수 있다.
            ("적절한 래퍼(wrapper)로 더 나아지지 않을까"라고 주장할 수도 있을
            것이다. 그러나 그것은 두 경우 모두 마찬가지가 아닐까? 또한, 다른
            사람이 배워야 할 문법을 추가하는 것이 아니라 언어를 더 작게 만드는
            것이 목표임을 기억하라.)
          </p>
          <p>
             두 경우 모두 각각 다른 장단점을 가지고 있고, 명백히 더 나은
             해결법이 없다. 간단함의 원칙은 이들 중 하나를 택해야 한다는 점이다.
             그리고 다수의 결정은 <code>printf</code> +
             <code>read</code>/<code>write</code> 이다.
          </p>
        <p></p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%84%EC%9C%84_%EC%A6%9D%EA%B0%80%EC%99%80_%EC%A0%84%EC%9C%84_%EA%B0%90%EC%86%8C" id="전위_증가와_전위_감소">전위 증가와 전위 감소</a></h3>
<span class="link_button" id="link-전위_증가와_전위_감소__button" name="link-전위_증가와_전위_감소__button"><a href="?showone=%EC%A0%84%EC%9C%84_%EC%A6%9D%EA%B0%80%EC%99%80_%EC%A0%84%EC%9C%84_%EA%B0%90%EC%86%8C#%EC%A0%84%EC%9C%84_%EC%A6%9D%EA%B0%80%EC%99%80_%EC%A0%84%EC%9C%84_%EA%B0%90%EC%86%8C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('전위_증가와_전위_감소')" name="전위_증가와_전위_감소__button" id="전위_증가와_전위_감소__button">▶</span>
    <div style="display:inline;" class="">
      이터레이터 및 다른 템플릿 객체들의 증가와 감소 연산자에 접두어 형태
       (<code>++i</code>) 를 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="전위_증가와_전위_감소__body" id="전위_증가와_전위_감소__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        변수의 값이 증가하거나(<code>++i</code> 또는 <code>i++</code>),
        감소하며(<code>--i</code> 또는 <code>i--</code>), 표현식의 결과값이
        쓰이지 않는다면, 전위 증가 (감소) 방식과 후위 증가 (감소) 방식 중에
        하나를 선택해야 한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        리턴값이 무시될 때, "접두 형태" (<code>++i</code>)는 "접미 형태"
        (<code>i++</code>)에 비해 비효율적일 리가 없다. 이것은
        후위 증가 (혹은 감소) 방식은 만들어질 <code>i</code> 의 복사본을
        요구하기 때문이다. 만약 <code>i</code>가 이터레이터이거나
        스칼라 타입이 아닌 타입이라면, <code>i</code>의 복사는 비용이 비쌀 수
        있다. 값이 무시되는 경우 두 증가 방식 모두 같은 거동이라면 그냥 항상
        전위 증가 방식만 사용하는 것이 좋지 않을까?
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        값이 사용되지 않는 경우 (특히 <code>for</code> 루프에서) 전통적으로 후위
        증가 방식이 사용되어 왔다.
        영어와 같이 주어(<code>i</code>)가 동사(<code>++</code>)보다 먼저
        나오기 때문에 후위 증가 방식이 읽기 편하다는 사람도 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        간단한 (객체가 아닌) 스칼라 값들에서는 하나의 형식을 선호할 이유가
        없다. 이터레이터나 다른 템플릿 타입들에서는 전위 증가 방식을 사용하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="const%EC%9D%98_%EC%82%AC%EC%9A%A9" id="const의_사용">const의 사용</a></h3>
<span class="link_button" id="link-const의_사용__button" name="link-const의_사용__button"><a href="?showone=const%EC%9D%98_%EC%82%AC%EC%9A%A9#const%EC%9D%98_%EC%82%AC%EC%9A%A9">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('const의_사용')" name="const의_사용__button" id="const의_사용__button">▶</span>
    <div style="display:inline;" class="">
      일리가 있다고 생각되면 항상 <code>const</code>를 사용하라.
      C++11 에서는 경우에 따라 const 보다 <code>constexpr</code>을 쓰는 편이
      낫다.
    </div>
    <div class=""><div class="stylepoint_body" name="const의_사용__body" id="const의_사용__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        선언된 변수와 인자들 앞에는 변수들이 변하지 않을 것임을
        알리기 위해 <code>const</code>가 올 수 있다
        (예를 들면 <code>const int foo</code>).
        클래스 함수들은 클래스 멤버 변수들의 상태를 변경하지
        않음을 알리기 위해 <code>const</code> 수식어를 가질 수 있다
        (예를 들면 <code>class Foo { int Bar(char c) const;};</code>).
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        어떻게 변수들이 쓰이는지 사람들이 이해하기 쉽다.
        컴파일러가 타입 체크를 더 잘하게 하고, (아마도) 더 나은 코드를
        생성하게 한다. 호출한 함수가 변수들을 어떻게 변경할지가 제한되어
        있다는 것을 알기 때문에 사람들이 프로그램의 정확함을
        이해하는 데 도움을 준다. 멀티쓰레드 프로그램에서 락(lock)이 없이
        사용하기에 안전한 함수인지를 알 수 있게 도와준다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        <code>const</code>는 전염성이 강하다. 만약 <code>const</code> 변수
        하나를 함수에 넘겨준다면, 그 함수는 반드시 그 프로토타입에
        <code>const</code>를 가져야 한다. (그렇지 않다면 그 변수에는
        <code>const_cast</code>가 필요할 것이다.) 이것은 라이브러리 함수들을
        호출할 때 특히 문제가 될 수 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          <code>const</code> 변수, 데이터 멤버, 메서드, 인자는 컴파일 시에 타입
          체크 단계를 추가한다. 이것은 오류를 가능한 한 빨리 찾기 위해서 더
          좋다. 그러므로 <code>const</code> 를 합당한 곳마다 사용하기를 강력히
          권장한다.
        </p>
        <ul>
          <li> 만약 함수가 레퍼런스나 포인터에 의해서 전달된 인자를 변경하지
               않으면, 인자는 <code>const</code>여야 한다.
               </li>
          <li> 가능한 곳마다 <code>const</code>로 메서드를 선언하라.
               접근자는 거의 항상 <code>const</code>여야 한다.
               그 외 다른 메서드들의 경우 데이터 멤버들을 수정하지 않고,
               <code>const</code>가 아닌 메서드들을 호출하지 않으며,
               데이터 멤버에 <code>const</code>가 아닌 포인터나 레퍼런스를
               반환하지 않는다면 const여야 한다.
               </li>
          <li> 생성된 후 수정될 필요가 없는 데이터 멤버들은
               <code>const</code> 로 만드는 것을 고려하라
               </li>
        </ul>
        <p>
          <code>mutable</code> 키워드는 허용되지만, 쓰레드와 함께
          사용될 때 안전하지 않다. 그래서 쓰레드 안전을 신중히 고려해야 한다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">const의 위치</span>
        </p><p>
          어떤 사람들은 <code>const int* foo</code>보다
          <code>int const *foo</code> 형태를 선호한다.
          그들은 이 형태가 더 일관성이 있기 때문에 더 읽기 쉽다고 주장한다.
          이 형태는 <code>const</code> 가 항상 기술하는 객체 뒤에 있는 규칙을
          따른다.
          그러나 일관성에 근거한 이러한 주장은, 간혹 볼 수 있는 깊게 중첩된 
          포인터 표현식에 적용되지 않는다. 왜냐하면 <code>const</code> 표현식의
          대부분은 단 하나의 <code>const</code>를 가지고 있고,
          이 <code>const</code>는 기저의 값에 적용되기 때문이다. 이런 경우들에
          유지할 일관성은 없다. (<code>const</code>와 같은) "형용사"가
          (<code>int</code>와 같은) "명사"보다 앞에 있는 것이 영문법에 맞기
          때문에 <code>const</code>를 앞에 두는 것이 거의 틀림없이 가독성이 더
          좋을 것이다.
        </p>
        <p>
          그러므로 <code>const</code>를 앞에 두는 것을 권장하지만, 강제하지는
          않는다. 하지만 주변 코드와 일관성을 유지하라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="constexpr%EC%9D%98_%EC%82%AC%EC%9A%A9" id="constexpr의_사용">constexpr의 사용</a></h3>
<span class="link_button" id="link-constexpr의_사용__button" name="link-constexpr의_사용__button"><a href="?showone=constexpr%EC%9D%98_%EC%82%AC%EC%9A%A9#constexpr%EC%9D%98_%EC%82%AC%EC%9A%A9">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('constexpr의_사용')" name="constexpr의_사용__button" id="constexpr의_사용__button">▶</span>
    <div style="display:inline;" class="">
      C++11에서 진짜 상수를 정의하거나 상수 초기화를 확실히 하기 위해
      <code>constexpr</code>를 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="constexpr의_사용__body" id="constexpr의_사용__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        어떤 변수들은 변수들이 (예를 들어 컴파일, 링크 시간에 고정되는)
        진짜 상수라는 것을 알리기 위해 <code>constexpr</code>로 선언될 수 있다.
        어떤 함수와 생성자들은 <code>constexpr</code>로 선언되어,
        <code>constexpr</code> 변수들을 정의할 수 있게 된다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        단순 리터럴 상수가 아닌 실수 표현식의 상수, 사용자 정의 타입의 상수,
        합수 호출을 포함하는 상수를 <code>constexpr</code>를 사용하여 정의할 수
        있다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        성급하게 무언가를 constexpr로 만들면 나중에 다운그레이드를 해야 할 때
        마이그레이션 문제가 발생할 수 있다. constexpr 함수와 생성자들에서 정의
        가능한 것이 현재 제한적이기 때문에, 불분명한 회피방법들이 정의에 포함될
        수도 있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          <code>constexpr</code>를 통해 인터페이스의 상수 부분을 더 견고하게
          명세할 수 있게 된다.
          constexpr의 정의에 부합하는 진짜 상수와 함수들에
          <code>constexpr</code>를 사용하라.
          <code>constexpr</code>를 사용하기 위해 함수 정의를 복잡하게 하지 말라.
          inline 을 강제하기 위해 <code>constexpr</code> 를 사용하지 말라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%95%EC%88%98_%ED%83%80%EC%9E%85%EB%93%A4" id="정수_타입들">정수 타입들</a></h3>
<span class="link_button" id="link-정수_타입들__button" name="link-정수_타입들__button"><a href="?showone=%EC%A0%95%EC%88%98_%ED%83%80%EC%9E%85%EB%93%A4#%EC%A0%95%EC%88%98_%ED%83%80%EC%9E%85%EB%93%A4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('정수_타입들')" name="정수_타입들__button" id="정수_타입들__button">▶</span>
    <div style="display:inline;" class="">
      C++ 정수 내장 타입 중에서 사용되는 유일한 것은 <code>int</code>다.
      만약 다른 크기의 변수들이 필요하면 <code>int16_t</code>처럼
      <code>&lt;stdint.h&gt;</code>에 있는 정확하게 크기가 정해진 정수 타입을
      사용하라. 만약 변수가 2^31 (2GiB) 보다 크거나 같은 값을 표현한다면,
      <code>int64_t</code> 같은 64비트 타입을 사용하라.
      값이 <code>int</code>에 담기 너무 크지 않더라도 계산의 과정에서 더 큰
      타입이 필요할 수 있다는 점을 명심하라.
      의심되는 경우에는 더 큰 타입을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="정수_타입들__body" id="정수_타입들__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        C++ 은 정수 타입의 크기를 명시하지 않는다. 전형적으로
        <code>short</code>는 16비트, <code>int</code>는 32비트,
        <code>long</code>이 32비트, <code>long long</code>이 64비트라고
        가정된다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        선언의 일률성.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        C++ 의 정수 타입들의 크기들은 컴파일러와 아키텍쳐에 따라 달라질 수
        있다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          <code>&lt;stdint.h&gt;</code>는 <code>int16_t</code>,
          <code>uint32_t</code>, <code>int64_t</code>와 같은 타입을 정의한다.
          정수의 크기를 보장해야 할 필요가 있을 때 <code>short</code>,
          <code>unsigned long long</code>보다 이런 타입을 항상 사용해야 한다.
          C 정수 타입들에서는 <code>int</code>만 사용해야 한다.
          적절한 경우 <code>size_t</code>와 <code>ptrdiff_t</code> 같은
          표준 타입들을 사용하는 것은 괜찮다.
        </p>
        <p>
          반복문 카운터처럼 심하게 커지지 않는다는 것을 아는 정수
          타입에 매우 흔하게 <code>int</code>를 사용한다. 이런 경우에는 
          평범한 <code>int</code>를 사용하라. <code>int</code>를 최소 32비트라고
          가정해야 하지만, 32비트 이상이라고 가정하면 안 된다. 만약 64비트 정수
          타입이 필요하다면 <code>int64_t</code> 혹은 <code>uint64_t</code>를
          사용하라.
        </p>
        <p>
          "큰" 숫자가 될 수 있는 정수 타입에는 <code>int64_t</code>를 쓰라.
        </p>
        <p>
          숫자가 아닌 비트 패턴을 표현한다거나, 2^N 오버플러우의 나머지 연산을
          정의한다거나 하는 분명한 목적이 없다면 <code>uint32_t</code> 처럼
          부호 없는 정수 타입을 사용하지 말라. 특히 숫자가 절대 음수가 되지 않을
          것을 말하기 위해 부호 없는 타입들을 사용하지 말라.
          대신 assertion을 사용해서 이를 보장하라.
        </p>
        <p>
          크기를 반환하는 컨테이너라면, 컨테이너의 가능한 모든 사용을 수용할 수
          있는 타입을 사용하라.
          의심된다면 작은 타입 대신 더 큰 타입을 사용하라.
        </p>
        <p>
          정수 타입들을 변환할 때 조심하라. 정수의 변환과 승격(promotion)은
          직관적이지 않은 행동을 유발할 수 있다.
        </p>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">부호없는 정수</span>
        </p><p>
          몇몇 교과서 저자들을 비롯해서 어떤 사람들은 절대 음수가 될 수 없는
          숫자를 표현하기 위해서 부호없는 타입들을 사용하는 것을 권장한다.
          이것은 자기 문서화를 하기 위한 형태이다. 그러나 C에서는 그런 문서화의
          장점보다 그것이 만들어 낼 수 있는 실제 버그가 더 중요하다.
          아래의 코드를 생각해보자.
        </p>
        <div class=""><pre>for (unsigned int i = foo.Length()-1; i &gt;= 0; --i) ...</pre></div>
        <p>
          이 코드는 절대 종료하지 않는다! 가끔 gcc 는 이 버그를 경고하지만,
          경고하지 않는 경우도 많다. 마찬가지로 부호 있는 타입의 변수들과
          부호 없는 타입의 변수들을 비교할 때 나쁜 버그들이 발생할 수 있다.
          근본적으로 C의 자동 형 변환 방식은 부호 없는 타입들이 기대와 다르게
          거동하는 원인이 된다.
        </p>
        <p>
          따라서 assertion을 사용해서 변수가 음수가 아니라는 것을 문서화하라.
          부호없는 타입을 사용하지 말라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="64%EB%B9%84%ED%8A%B8_%EC%9D%B4%EC%8B%9D%EC%84%B1" id="64비트_이식성">64비트 이식성</a></h3>
<span class="link_button" id="link-64비트_이식성__button" name="link-64비트_이식성__button"><a href="?showone=64%EB%B9%84%ED%8A%B8_%EC%9D%B4%EC%8B%9D%EC%84%B1#64%EB%B9%84%ED%8A%B8_%EC%9D%B4%EC%8B%9D%EC%84%B1">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('64비트_이식성')" name="64비트_이식성__button" id="64비트_이식성__button">▶</span>
    <div style="display:inline;" class="">
      코드는 64비트와 32비트에 대해 모두 친화적이어야 한다. 출력, 비교, 구조체
      정렬(alignment)시 발생하는 문제점에 유의하라.
    </div>
    <div class=""><div class="stylepoint_body" name="64비트_이식성__body" id="64비트_이식성__body" style="display: none">
      <ul>
        <li>
          <p>
            <code>printf()</code> 포맷 지정자 중에서 몇 가지 타입은 64비트와
            32비트에 대해 완전한 이식성을 가지지 않는다. C99는 이식 가능한 포맷
            지정자를 정의한다. 불행히도 MSVC 7.1에서 이 중 몇 가지가 동작하지
            않고 표준 중에서 몇 가지가 빠졌다.
            그래서 몇 가지 경우에 대한 못 생긴 버전을 정의했다.
            (표준 인클루드 파일인 <code>inttypes.h</code>의 스타일에 맞추어)
          </p>
          <div class=""><pre>// inttypes.h 에서 size_t를 위한 printf 매크로
#ifdef _LP64
#define __PRIS_PREFIX "z"
#else
#define __PRIS_PREFIX
#endif

// 32비트, 64비트에서 잘 동작하게 하려면 printf 포맷 문자열에서
// 아래 매크로를 % 뒤에 사용하라. 예를 들면
// size_t size = records.size();
// printf("%"PRIuS"\n", size);

#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"</pre></div>
          <table border="1" summary="portable printf specifiers">
            
              <tbody><tr align="center">
                <th>Type</th>
                <th>DO NOT use</th>
                <th>DO use</th>
                <th>Notes</th>
              </tr>
              <tr align="center">
                <td>
<code>void *</code> (or any pointer)</td>
                <td><code>%lx</code></td>
                <td><code>%p</code></td>
                <td> </td>
              </tr>

              <tr align="center">
                <td><code>int64_t</code></td>
                <td>
<code>%qd</code>,
                     <code>%lld</code>
</td>
                <td><code>%"PRId64"</code></td>
                <td></td>
              </tr>

              <tr align="center">
                <td><code>uint64_t</code></td>
                <td>
<code>%qu</code>,
                    <code>%llu</code>,
                    <code>%llx</code>
</td>
                <td>
<code>%"PRIu64"</code>,
                    <code>%"PRIx64"</code>
</td>
                <td></td>
              </tr>

              <tr align="center">
                <td><code>size_t</code></td>
                <td><code>%u</code></td>
                <td>
<code>%"PRIuS"</code>,
                    <code>%"PRIxS"</code>
</td>
                  <td>
                      C99 specifies <code>%zu</code>
</td>
              </tr>
              <tr align="center">
                <td><code>ptrdiff_t</code></td>
                <td><code>%d</code></td>
                <td><code>%"PRIdS"</code></td>
                <td>
                    C99 specifies <code>%td</code>
</td>
              </tr>

            
          </tbody></table>
          <p>
            <code>PRI*</code> 매크로는 컴파일러가 연결해주는 개별 문자열들로
            확장된다. 비상수 포맷 문자열을 사용한다면 매크로 값을 이름에
            넣는 것보다 포맷에 넣는 것이 좋다. 일반적으로 <code>PRI*</code>
            매크로를 사용할 때, <code>%</code>뒤에 길이 지정자 등을 넣는 것은
            여전히 가능하다. 예를 들면
            <code>printf("x = %30"PRIuS"\n", x)</code>는 32비트 리눅스에서
            <code>printf("x = %30" "u" "\n", x)</code>으로 확장될 것이고,
            컴파일러는 <code>printf("x = %30u\n", x)</code>로 간주할 것이다.
          </p>

        </li>

        <li> <code>sizeof(void *)</code> != <code>sizeof(int)</code> 라는 것을
             기억하라. 포인터 크기의 정수가 필요하면 <code>intptr_t</code>를
             사용하라.
             </li>

        <li> 구조체 정렬을 다루는데 주의해야 한다. 특히 구조체가 디스크에 저장될
             때 더욱 주의가 필요하다. <code>int64_t</code>/<code>uint64_t</code>
             멤버를 가진 클래스와 구조체는 64비트 시스템에서 기본으로 8바이트
             정렬된다. 32비트와 64비트에서 디스크에 공유되는 구조체는 두
             시스템에서 모두 같은 방식으로 패킹되어야 한다. 대부분의 컴파일러는
             구조체 정렬을 변경하는 방법을 제공한다. gcc에서는
             <code>__attribute__((packed))</code>를 사용할 수 있고, MSVC에서는
             <code>#pragma pack()</code>과 <code>__declspec(align())</code>을
             사용할 수 있다.
             </li>

        <li>
             64비트 상수 초기화에는 <code>LL</code> 이나 <code>ULL</code>
             접미사를 사용하라. 예를 들면

             <div class=""><pre>int64_t my_value = 0x123456789LL;
uint64_t my_mask = 3ULL &lt;&lt; 48;</pre></div>
             </li>

        <li> 굳이 32비트와 64비트에서 다른 코드가 필요하다면
             <code>#ifdef _LP64</code>를 사용하라(가능하면 사용하지 않는 것이
             최선이지만).
             </li>
      </ul>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C" id="전처리기_매크로">전처리기 매크로</a></h3>
<span class="link_button" id="link-전처리기_매크로__button" name="link-전처리기_매크로__button"><a href="?showone=%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('전처리기_매크로')" name="전처리기_매크로__button" id="전처리기_매크로__button">▶</span>
    <div style="display:inline;" class="">
      매크로는 매우 주의해서 사용하라. 매크로보다는 인라인 함수, 열거형,
      <code>const</code> 변수를 선호하라.
    </div>
    <div class=""><div class="stylepoint_body" name="전처리기_매크로__body" id="전처리기_매크로__body" style="display: none">
      <p>
        매크로는 프로그래머가 보는 코드와 컴파일러가 보는 코드를 다르게 만든다.
        특히, 매크로는 전역 범위(scope)를 가지기 때문에,
        예상치 못한 결과를 초래할 수 있다.
      </p>
      <p>
        다행스럽게도 C++에서는 C와는 달리 매크로의 사용이 필수가 아니다.
        성능이 민감한 코드에는 매크로 대신 인라인 함수를 사용하라.
        상수를 저장하는 용도로 매크로 대신에 <code>const</code> 변수를 사용하라.
        긴 변수 이름을 축약하는 용도로 매크로 대신에 레퍼런스를 사용하라.
        조건부로 코드를 컴파일하는 용도로는, 글쎄, 아예 그렇게 하지 말라.
        (예외적으로 헤더파일 이중 include를 막는
        <code>#define</code> 가드 용도로는 사용해도 됨). 테스트를 훨씬 어렵게
        만든다.
      </p>
      <p>
        매크로는 다른 테크닉으로는 할 수 없는 것들을 가능케 하고, 하부 레벨의
        라이브러리 코드베이스에서 종종 볼 수 있다.그리고 문자열로 변환하는
        기능이나 문자열을 연결하는 기능과 같은 고유한 기능이 있다. 하지만
        매크로를 사용하기 전에 매크로를 사용하지 않고도 같은 결과를 얻을 수 있는
        다른 방법을 신중하게 고려하라.
      </p>
      <p>
        아래 사용패턴을 따르면 매크로의 문제점들을 회피할 수 있다.
        매크로를 쓰려면 되도록 이를 따르자.
      </p>
      <ul>
        <li> 헤더파일에 매크로를 정의하지 말라.
             </li>
        <li> 매크로를 사용하기 바로 전에 <code>#define</code>하고,
             사용 후에는 바로 <code>#undef</code> 하라.
             </li>
        <li> 기존에 존재하는 매크로를 대체하는 용도로 <code>#undef</code>를
             사용하지 말고, 다른 유일한 이름의 매크로를 사용하라.
             </li>
        <li> 불균형한 C++구조로 확장되는
             매크로를 사용하지 말고, 사용하게 된다면 적어도 문서화라도 하라.
             </li>
        <li> 함수/클래스/변수 이름을 생성하는 용도로 <code>##</code> 매크로를
             사용하지 말라.
             </li>
      </ul>
    </div></div>
  </div>

  <div class="">
<h3><a name="0%EA%B3%BC_nullptr/NULL" id="0과_nullptr/NULL">0과 nullptr/NULL</a></h3>
<span class="link_button" id="link-0과_nullptr/NULL__button" name="link-0과_nullptr/NULL__button"><a href="?showone=0%EA%B3%BC_nullptr/NULL#0%EA%B3%BC_nullptr/NULL">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('0과_nullptr/NULL')" name="0과_nullptr/NULL__button" id="0과_nullptr/NULL__button">▶</span>
    <div style="display:inline;" class="">
      정수는 <code>0</code> 을, 실수는 <code>0.0</code> 을,
      포인터는 <code>nullptr</code> (혹은 <code>NULL</code>) 을,
      char는 <code>'\0'</code> 을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="0과_nullptr/NULL__body" id="0과_nullptr/NULL__body" style="display: none">
      <p>
        정수는 <code>0</code> 을, 실수는 <code>0.0</code> 을 사용하는 것은
        명백하므로 논란이 없다.
      </p>
      <p>
        포인터(변수를 가리키는 용도)에는 <code>0</code>, <code>NULL</code>,
        <code>nullptr</code>을 선택적으로 사용할 수 있다. C++11을 허용하는
        프로젝트에서는 <code>nullptr</code>을 사용하라. C++03 프로젝트에는 NULL이
        포인터처럼 보이기 때문에 NULL을 권장한다. 사실 어떤 C++ 컴파일러는
        유용한 경고메세지를 보여주는 것을 가능케 하는(예를 들면 sizeof(NULL)과
        sizeof(0)이 같지 않은 상황) NULL에 대한 특별한 정의가 있다.
      </p>
      <p>
        char에는 '\0'을 사용하라. 알맞은 타입이고 코드 가독성도 향상된다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="sizeof" id="sizeof">sizeof</a></h3>
<span class="link_button" id="link-sizeof__button" name="link-sizeof__button"><a href="?showone=sizeof#sizeof">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('sizeof')" name="sizeof__button" id="sizeof__button">▶</span>
    <div style="display:inline;" class="">
      <code>sizeof(<var>type</var>)</code>보다
      <code>sizeof(<var>varname</var>)</code> 사용을 권장한다.
    </div>
    <div class=""><div class="stylepoint_body" name="sizeof__body" id="sizeof__body" style="display: none">
      <p>
        특정 변수의 사이즈가 필요할 때 <code>sizeof(<var>varname</var>)</code>을
        사용하라. <code>sizeof(<var>varname</var>)</code>는 누군가가 그 변수의
        타입을 변경했을 때에도 문제가 없다.
        <code>sizeof(<var>type</var>)</code>은 특정 변수의 사이즈와 관련 없는 곳
        (예를 들면 외부나 내부의 데이터 포맷을 관리하는 것)에서 사용될 수 있다.
      </p>
      <p>
        </p><div class=""><pre>Struct data;
memset(&amp;data, 0, sizeof(data));</pre></div>
        <div class=""><pre class="badcode">memset(&amp;data, 0, sizeof(Struct));</pre></div>
        <div class=""><pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "압축된 레코드가 너무 작다: " &lt;&lt; raw_size;
  return false;
}</pre></div>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="auto" id="auto">auto</a></h3>
<span class="link_button" id="link-auto__button" name="link-auto__button"><a href="?showone=auto#auto">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('auto')" name="auto__button" id="auto__button">▶</span>
    <div style="display:inline;" class="">
      타입이름을 사용하기 복잡한 곳에 <code>auto</code>를 사용하라.
      코드 가독성을 향상시켜주는 곳에는 명시적인 타입 선언을 사용하고,
      <code>auto</code>는 지역 변수에만 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="auto__body" id="auto__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        C++11에서의 <code>auto</code> 타입의 변수 표현식에서 변수 초기화에
        사용된다. 복사를 통해 변수를 초기화 하거나 레퍼런스를 생성하는 데에
        <code>auto</code>를 사용할 수 있다.
        </p><div class=""><pre>vector&lt;string&gt; v;
...
auto s1 = v[0];  // v[0]의 복사본을 만든다.
const auto&amp; s2 = v[0];  // s2는 v[0]의 레퍼런스다.</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><p>
          C++의 타입네임은 템플릿이나 네임스페이스와 연관되어 있을 때에는
          길고 복잡해진다. 예를 들면 아래 코드에서
          </p><div class=""><pre>sparse_hash_map&lt;string, int&gt;::iterator iter = m.find(val);</pre></div>
          리턴 타입이 무엇인지, 구문의 목적이 무엇인지 알기가 어렵다.
          하지만 아래와 같이 변경하면 가독성이 향상된다.
          <div class=""><pre>auto iter = m.find(val);</pre></div>
        <p></p>
        <p>
          <code>auto</code>가 없으면 한 구문에서 별 의미도 없이
          타입네임을 두 번 써야 하는 경우도 있다.
          </p><div class=""><pre>diagnostics::ErrorStatus* status = new diagnostics::ErrorStatus("xyz");</pre></div>
        <p></p>
        <p>
          <code>auto</code>를 사용하면 타입을 명시적으로 써야하는 부담을 덜고
          적절한 변수를 바로 사용하는 것이 쉬워진다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
          어떤 변수의 초기화가 멀리 선언되어 있는 다른 변수와 관련되어 있을
          때에는 명시적인 타입을 사용하는 것이 명확할 때가 있다. 아래 구문에서
          </p><div class=""><pre>auto i = x.Lookup(key);</pre></div>
          x가 선언된 부분이 코드에서 멀리 있으면, i의 타입이 무엇인지 알아내기가
          쉽지 않다.
        <p></p>
        <p>
          프로그래머가 <code>auto</code>와 <code>const auto&amp;</code>의 차이를
          잘 알지 못하면  원치 않게 복사된 값을 얻게 될 수 있다.
        </p>
        <p>
          <code>auto</code>와 C++11의 "중괄호 리스트 초기화"의 상호작용은
          혼란스러울 수 있다. 아래 두 선언은 서로 다른 의미를 가진다.
          </p><div class=""><pre>auto x(3);  // Note: 소괄호
auto y{3};  // Note: 중괄호</pre></div>
          <code>x</code>는 int이고, <code>y</code>는 중괄호 초기화 리스트이다.
          invisible proxy도 마찬가지이다.
        <p></p>
        <p>
          <code>auto</code> 변수가 인터페이스에 선언되어 있다면(예를 들어 헤더의
          상수로), 프로그래머가 그 값을 바꾸려 했는데 타입이 바뀌어 버리면서
          API가 근본적으로 변해버릴 수 있다.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          <code>auto</code>는 지역변수로만 사용해야 한다. 파일 범위나
          네임스페이스 범위에서 사용하면 안 되고, 클래스 멤버로도 사용해서는
          안 된다. <code>auto</code>타입 변수에 중괄호를 사용한 초기화 구문을
          사용해도 안 된다.
        </p>
        <p>
          <code>auto</code> 키워드는 C++11 의 기능 중 하나인 리턴 타입을
          함수 뒤에 쓰는 문법에도 사용된다. 이 문법은 사용하지 않는다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A4%91%EA%B4%84%ED%98%B8%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%B4%88%EA%B8%B0%ED%99%94" id="중괄호를_사용한_초기화">중괄호를 사용한 초기화</a></h3>
<span class="link_button" id="link-중괄호를_사용한_초기화__button" name="link-중괄호를_사용한_초기화__button"><a href="?showone=%EC%A4%91%EA%B4%84%ED%98%B8%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%B4%88%EA%B8%B0%ED%99%94#%EC%A4%91%EA%B4%84%ED%98%B8%EB%A5%BC_%EC%82%AC%EC%9A%A9%ED%95%9C_%EC%B4%88%EA%B8%B0%ED%99%94">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('중괄호를_사용한_초기화')" name="중괄호를_사용한_초기화__button" id="중괄호를_사용한_초기화__button">▶</span>
    <div style="display:inline;" class="">
      중괄호 리스트 초기화를 사용할 수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="중괄호를_사용한_초기화__body" id="중괄호를_사용한_초기화__body" style="display: none">
      <p>
        C++03에서 (배열, 생성자 없는 구조체와 같은) aggregate 타입은 중괄호를
        사용해서 초기화 될 수 있다.
        </p><div class=""><pre>struct Point { int x; int y; };
Point p = {1, 2};</pre></div>
      <p></p>
      <p>
        C++11에서는 이 문법이 모든 데이터타입으로 확장되었다.
        이런 중괄호를 사용한 초기화 형태를 "중괄호 리스트 초기화"라고 부른다.
        아래에 몇가지 예제가 있다.
        </p><div class=""><pre>// 요소 리스트를 받는 벡터 초기화.
vector&lt;string&gt; v{"foo", "bar"};

// 중괄호 리스트의 생성자가 explicit인 경우를 제외하고 사용가능
vector&lt;string&gt; v = {"foo", "bar"};

// 중첩된 중괄호 리스트 초기화를 사용한 맵 초기화.
map&lt;int, string&gt; m = {{1, "one"}, {2, "2"}};

// 중괄호 초기화 리스트는 암묵적으로 리턴타입으로 변환될 수 있다.
vector&lt;int&gt; test_function() {
  return {1, 2, 3};
}

// 중괄호 초기화 리스트를 순환.
for (int i : {-1, -2, -3}) {}

// 중괄호 초기화 리스트를 사용하여 함수 호출
void test_function2(vector&lt;int&gt; v) {}
test_function2({1, 2, 3});</pre></div>
      <p></p>
      <p>
        사용자 정의 타입 또한 <i>중괄호 초기화 리스트</i>로부터 자동 생성되는
        <code>initializer_list</code>를 받는 생성자를 정의할 수 있다.
        </p><div class=""><pre>class MyType {
 public:
  // initializer_list는 기반 초기화 리스트의 레퍼런스이므로
  // 값으로(by value) 전달할 수 있다.
  MyType(initializer_list&lt;int&gt; init_list) {
    for (int element : init_list) {}
  }
};
MyType m{2, 3, 5, 7};</pre></div>
      <p></p>
      <p>
        마지막으로, 중괄호를 사용한 초기화는 <code>initializer_list</code>
        생성자를 가지지 않는 일반적인 생성자를 호출할 수 있다.
        </p><div class=""><pre>double d{1.23};
// MyOtherType가 initializer_list 생성자를
// 가지지 않는다면 일반적인 생성자를 호출
class MyOtherType {
 public:
  explicit MyOtherType(string);
  MyOtherType(int, string);
};
MyOtherType m = {1, "b"};
// 생성자가 explicit이라면 "= {}" 형태 사용 불가
MyOtherType m{"b"};</pre></div>
      <p></p>
      <p>
        <i>중괄호 초기화 리스트</i>를 auto 지역 변수에 할당하지 말라.
        요소가 하나인 경우에 혼동스러울 수 있다.
        </p><div class=""><pre class="badcode">auto d = {1.23};        // d는 initializer_list&lt;double&gt;이다</pre></div>
        <div class=""><pre>auto d = double{1.23};  // 좋음 -- d는 initializer_list가 아니라 double.</pre></div>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%9E%8C%EB%8B%A4_%ED%91%9C%ED%98%84%EC%8B%9D" id="람다_표현식">람다 표현식</a></h3>
<span class="link_button" id="link-람다_표현식__button" name="link-람다_표현식__button"><a href="?showone=%EB%9E%8C%EB%8B%A4_%ED%91%9C%ED%98%84%EC%8B%9D#%EB%9E%8C%EB%8B%A4_%ED%91%9C%ED%98%84%EC%8B%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('람다_표현식')" name="람다_표현식__button" id="람다_표현식__button">▶</span>
    <div style="display:inline;" class="">
      람다 표현식과 그와 연관이 있는 <code>std::function</code> 혹은
      <code>std::bind</code> 유틸리티를 사용하지 말라.
    </div>
    <div class=""><div class="stylepoint_body" name="람다_표현식__body" id="람다_표현식__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        람다 표현식으로 익명 함수 객체를 간결하게 생성할 수 있다. 함수의
        인자로 사용할 때 유용하다. 예를 들면 <code>std::sort(v.begin(),
        v.end(), [](string x, string y) { return x[1] &lt; y[1]; });
        </code>. 람다는 C++11에서 다형성 래퍼(wrapper)인
        <code>std::function</code>을 비롯한 함수객체를 위한 유틸리티들과 함께
        소개되었다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        </p><ul>
          <li>
            람다로 STL 알고리즘의 인자로 전달되는 함수객체를 다른 방식보다
            훨씬 간결하게 만들 수 있고, 가독성도 향상된다.
          </li>
          <li>
            람다, <code>std::function</code>, <code>std::bind</code>는
            일반적인 콜백 방식에 함께 사용될 수 있다. 함수를 인자로 쉽게
            사용할 수 있게 해 준다.
          </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><ul>
          <li>
            람다의 변수 캡쳐는 사용하기 까다로울 수 있고, dangling-pointer
            버그의 온상이 될 수 있다.
          </li>
          <li>
            매우 길게 중첩된 익명함수는 코드를 이해하기 어렵고 감당할 수 없게
            만든다.
          </li>
        </ul>
      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          람다 표현식, <code>std::function</code>, <code>std::bind</code>는
          사용하지 말라.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="Boost" id="Boost">Boost</a></h3>
<span class="link_button" id="link-Boost__button" name="link-Boost__button"><a href="?showone=Boost#Boost">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('Boost')" name="Boost__button" id="Boost__button">▶</span>
    <div style="display:inline;" class="">
      Boost 라이브러리 모음에서 공인된 라이브러리만 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="Boost__body" id="Boost__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        <a href="http://www.boost.org/">Boost 라이브러리</a>는 프로그래머들
        사이에서 검증된 무료 오픈소스 라이브러리 모음이다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        Boost 코드는 일반적으로 매우 고품질이고, 이식성이 높고, type trait,
        binder, 스마트 포인터와 같은 C++ 표준 라이브러리의 부족함을
        충족시킨다. 또한 표준 라이브러리의 TR1 확장의 구현체를 제공한다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        일부 Boost 라이브러리는 메타프로그래밍이나 다른 고도의 템플릿 기법이나
        과도한 "함수형" 프로그래밍 기법 등의 가독성을 더욱 해칠 수 있는 코딩
        습관을 조장한다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><div>
          코드를 유지 보수하는 모든 프로그래머들에게 높은 수준의 코드 가독성을
          유지하기 위해 Boost의 공인된 일부 기능만 사용한다.
          현재로서는 아래의 라이브러리를 사용할 수 있다.
          <ul>
            <li> <code>boost/call_traits.hpp</code>의
                 <a href="http://www.boost.org/libs/utility/call_traits.htm">
                 Call Traits</a>
                 </li>
            <li> <code>boost/compressed_pair.hpp</code>의
                 <a href="http://www.boost.org/libs/utility/compressed_pair.htm">
                 Compressed Pair</a>
                 </li>
            <li> <code>boost/graph</code>의
                 <a href="http://www.boost.org/libs/graph/">
                 The Boost Graph Library (BGL)</a>,
                 예외로 직렬화 (<code>adj_list_serialize.hpp</code>),
                 병렬/분산 알고리즘과 데이터 구조
                 (<code>boost/graph/parallel/*</code>,
                 <code>boost/graph/distributed/*</code>)는 사용하지 말 것.
                 </li>
            <li> <code>boost/property_map</code>의
                 <a href="http://www.boost.org/libs/property_map/">프로퍼티 맵
                 </a>, 예외로 병렬/분산 프로퍼티 맵은 사용하지 말 것
                 (<code>boost/property_map/parallel/*</code>).
                 </li>
            <li> 이터레이터 정의를 다루는
                 <a href="http://www.boost.org/libs/iterator/">이터레이터</a>
                 부분: <code>boost/iterator/iterator_adaptor.hpp</code>,
                 <code>boost/iterator/iterator_facade.hpp</code>,
                 <code>boost/function_output_iterator.hpp</code>
                 </li>
            <li> Voronoi 다이어그램 생성과 연관되고 나머지 폴리곤과 무관한
                 <a href="http://www.boost.org/libs/polygon/">폴리곤</a> 부분:
                 <code>boost/polygon/voronoi_builder.hpp</code>,
                 <code>boost/polygon/voronoi_diagram.hpp</code>,
                 <code>boost/polygon/voronoi_geometry_type.hpp</code>
                 </li>
            <li> <code>boost/bimap</code>의
                 <a href="http://www.boost.org/libs/bimap/">비트맵</a>
                 </li>
            <li> <code>boost/math/distributions</code>의
                 <a href="http://www.boost.org/libs/math/doc/html/dist.html">
                 통계적 분포와 함수</a>
                 </li>
          </ul>
          다른 Boost 라이브러리도 허용 목록에 넣기 위해 활발하게 고려 중이므로
          위의 목록은 더 추가될 수 있다.
        </div>
        <p>
          아래 라이브러리도 사용이 가능하지만, C++ 11 확장 라이브러리로
          대체되었다.
          </p><ul>
            <li> <code>boost/array.hpp</code>의
                 <a href="http://www.boost.org/libs/array/">배열</a>은
                 <a href="http://en.cppreference.com/w/cpp/container/array">
                 <code>std::array</code></a>를 대신 사용하라.
                 </li>
            <li> <code>boost/ptr_container</code>의
                 <a href="http://www.boost.org/libs/ptr_container/">포인터
                 컨테이너 </a>는
                 <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
                 <code>std::unique_ptr</code></a>의 컨테이너를 대신 사용하라.
                 </li>
          </ul>
        <p></p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="C++11" id="C++11">C++11</a></h3>
<span class="link_button" id="link-C++11__button" name="link-C++11__button"><a href="?showone=C++11#C++11">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('C++11')" name="C++11__button" id="C++11__button">▶</span>
    <div style="display:inline;" class="">
      C++11(기존의 C++0x)를 적절한 곳에 사용하라.

      프로젝트에 C++11의 기능을 사용하기 전에 다른 환경으로의 이식성을
      고려하라.
    </div>
    <div class=""><div class="stylepoint_body" name="C++11__body" id="C++11__body" style="display: none">
      <p class="">
<span class="stylepoint_section">정의:  </span>
        C++11은 최신의 ISO C++ 표준이다.
        언어와 라이브러리의
        <a href="http://en.wikipedia.org/wiki/C%2B%2B11">중요한 변경</a> 이
        포함되어있다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        C++11은 공식 표준이고, 결국 대부분의 C++ 컴파일러가 지원하게
        될 것이다. 우리가 이미 사용하고 있는 공통 C++ 확장을 표준화했고,
        일부 연산의 약칭(shorthands)을 허용하며, 성능과 안정성이 향상되었다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        </p><p>
          C++11 표준은 이전 표준에 비해 상당히 복잡하고(1,300 페이지 대 800
          페이지), 많은 개발자들에게 생소하다. 몇 가지 기능에 대한 가독성과
          유지 보수에 대한 장기적인 효과도 알 수 없다. 특히 예전 버전의 툴을
          사용하도록 강제되는 프로젝트의 경우, 우리는 C++11의 다양한 기능이
          언제 모두 구현될 지 예측할 수 없다.
        </p>
        <p>
          <a href="#Boost">Boost</a> 와 마찬가지로, 어떤 C++11 확장은 코드
          가독성을 해치는 코드를 만든다. 예를 들자면 코드를 읽는 사람에게
          유용할 수 있는 (타입 이름과 같은) 반복 코드를 제거할 수 있는 기능과
          템플릿 메타프로그래밍을 장려하는 것 등이 있다. 어떤 확장은 기존
          라이브러리가 제공하는 기능을 중복 제공해서 혼란과 변환 비용을
          야기한다.
        </p>

      <p></p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
           아래 명시된 기능 외에는 사용해도 된다. 사용이 금지된 기능을 이
           문서의 다른 부분에서 추가적으로 언급할 수도 있다.
        </p>
        <ul>
          <li>
            리턴 타입을 함수 뒤에 쓰는 문법. 예를 들면
            <code>int foo();</code> 대신에
            <code>auto foo() -&gt; int;</code>로 쓰는 것. 기존의 많은 함수
            선언과 일관성을 유지하고 싶기 때문이다.
          </li>
          <li>
            컴파일타임 유리수(rational numbers) (<code>&lt;ratio&gt;</code>).
            비대한 템플릿 인터페이스 스타일과 엮일 수 있는 우려 때문이다.
          </li>
          <li>
            <code>&lt;cfenv&gt;</code>와 <code>&lt;fenv.h&gt;</code> 헤더.
            많은 컴파일러가 안정적으로 지원하지 않기 때문이다.
          </li>

          <li>
            람다 표현식, 혹은 그와 관련된<code>std::function</code>,
            <code>std::bind</code> 유틸리티.
          </li>
        </ul>
      <p></p>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="이름_규칙" id="이름_규칙">이름 규칙</h2>
  <p>
    일관성을 위한 가장 중요한 규칙은 이름 규칙을 통제하는 것이다. 이름의 
    스타일을 통해 요소의 선언을 찾지 않고도 해당 요소가 타입인지, 변수인지,
    함수인지, 상수인지, 혹은 매크로인지 바로 알 수 있다. 우리 머리 속의
    패턴매칭 엔진은 이러한 이름 규칙에 상당히 의존한다.
  </p>
  <p>
    이름 규칙은 상당히 모호하지만 이 영역에서 개인의 선호도보다 일관성이
    더 중요하다고 본다. 합리적이라고 생각하든 아니든 규칙은 지켜져야 한다.
  </p>

  <div class="">
<h3><a name="%EC%9D%BC%EB%B0%98_%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99" id="일반_이름_규칙">일반 이름 규칙</a></h3>
<span class="link_button" id="link-일반_이름_규칙__button" name="link-일반_이름_규칙__button"><a href="?showone=%EC%9D%BC%EB%B0%98_%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99#%EC%9D%BC%EB%B0%98_%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('일반_이름_규칙')" name="일반_이름_규칙__button" id="일반_이름_규칙__button">▶</span>
    <div style="display:inline;" class="">
      함수 이름, 변수 이름, 파일 이름은 약어를 피하고 서술적으로 지어야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="일반_이름_규칙__body" id="일반_이름_규칙__body" style="display: none">
      <p>
        가능하면 상세한 이름을 사용하라. 새로 읽는 사람이 즉시 이해할 수 있는
        것이 글자 길이를 줄이는 것보다 훨씬 중요하다. 프로젝트에 관계되지 않은
        사람이 익숙하지 않은 약어를 사용하지 말고 중간 글자를 지워서 축약하지
        말라.
      </p>
      <div class=""><pre>int price_count_reader;    // 축약없음.
int num_errors;            // "num"은 누구나 이해가능.
int num_dns_connections;   // "DNS"도 누구나 이해가능.</pre></div>
      <div class=""><pre class="badcode">int n;                     // 의미없음.
int nerr;                  // 모호한 축약.
int n_comp_conns;          // 모호한 축약.
int wgc_connections;       // 팀 내부사람들만 아는 약어.
int pc_reader;             // "pc"는 다양한 의미가 있다.
int cstmr_id;              // 중간 단어를 지웠음.</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%8C%8C%EC%9D%BC_%EC%9D%B4%EB%A6%84" id="파일_이름">파일 이름</a></h3>
<span class="link_button" id="link-파일_이름__button" name="link-파일_이름__button"><a href="?showone=%ED%8C%8C%EC%9D%BC_%EC%9D%B4%EB%A6%84#%ED%8C%8C%EC%9D%BC_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('파일_이름')" name="파일_이름__button" id="파일_이름__button">▶</span>
    <div style="display:inline;" class="">
      파일 이름은 모두 소문자이어야 하고 언더스코어 (<code>_</code>)
      혹은 대쉬 (<code>-</code>)를 포함할 수 있다. 반드시 언더스코어를
      사용할 필요는 없고 프로젝트에서 사용하는 관례를 따른다.
    </div>
    <div class=""><div class="stylepoint_body" name="파일_이름__body" id="파일_이름__body" style="display: none">
      <p>
        사용 가능한 파일 이름:
      </p>
      <p>
        <code>
          my_useful_class.cc<br>
          my-useful-class.cc<br>
          myusefulclass.cc<br>
          myusefulclass_test.cc  // _unittest와 _regtest는 deprecate되었다.<br>
        </code>
      </p>
      <p>
        C++ 파일은 <code>.cc</code>으로 끝나고 헤더 파일은 <code>.h</code>로
        끝난다.
      </p>
      <p>
        <code>db.h</code>와 같이 <code>/usr/include</code>에 이미 존재하는
        파일 이름은 사용하지 말라.
      </p>
      <p>
        일반적으로 상세하게 파일 이름을 지으라. 예를 들면
        <code>http_server_logs.h</code>가 <code>logs.h</code>보다 좋다.
        <code>FooBar</code> 클래스를 위한 파일 이름은 <code>foo_bar.h</code>,
        <code>foo_bar.cc</code>이다.
      </p>
      <p>
        인라인 함수는 <code>.h</code>에 있어야 한다. 인라인 함수의 코드가
        짧으면 <code>.h</code> 안에 들어가고, 길다면 <code>-inl.h</code>로
        가야 한다. 클래스 안에 많은 인라인 코드가 있다면 3개의 파일로 분리한다.
      </p>
      <div class=""><pre>url_table.h      // 클래스 선언
url_table.cc     // 클래스 정의
url_table-inl.h  // 많은 코드를 포함한 인라인 함수</pre></div>
      <p>
        <a href="#-inl.h_%ED%8C%8C%EC%9D%BC">-inl.h 파일</a> 섹션 참조.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%83%80%EC%9E%85_%EC%9D%B4%EB%A6%84" id="타입_이름">타입 이름</a></h3>
<span class="link_button" id="link-타입_이름__button" name="link-타입_이름__button"><a href="?showone=%ED%83%80%EC%9E%85_%EC%9D%B4%EB%A6%84#%ED%83%80%EC%9E%85_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('타입_이름')" name="타입_이름__button" id="타입_이름__button">▶</span>
    <div style="display:inline;" class="">
      타입 이름은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로
      대문자를 사용한다. 예를 들면 <code>MyExcitingClass</code>,
      <code>MyExcitingEnum</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="타입_이름__body" id="타입_이름__body" style="display: none">
      <p>
        클래스, 구조체, typedef, 열거형을 포함한 모든 타입에 대해 같은 규칙이
        적용된다. 다음 예시처럼 타입 이름은 단어마다 대문자로 시작하며
        언더스코어를 사용하지 않는다.
      </p>
      <div class=""><pre>// 클래스와 구조체
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedef
typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

// 열거형
enum UrlTableErrors { ...</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B3%80%EC%88%98_%EC%9D%B4%EB%A6%84" id="변수_이름">변수 이름</a></h3>
<span class="link_button" id="link-변수_이름__button" name="link-변수_이름__button"><a href="?showone=%EB%B3%80%EC%88%98_%EC%9D%B4%EB%A6%84#%EB%B3%80%EC%88%98_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('변수_이름')" name="변수_이름__button" id="변수_이름__button">▶</span>
    <div style="display:inline;" class="">
      변수 이름은 모두 소문자로 작성하며 단어 사이에 언더스코어를 사용한다.
      클래스 멤버 변수는 이름의 끝에 언더스코어를 사용한다. 예를 들면
      <code>my_exciting_local_variable</code>,
      <code>my_exciting_member_variable_</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="변수_이름__body" id="변수_이름__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">공통 사항</span>
        </p><p>
          예시:
        </p>
        <div class=""><pre>string table_name;  // 좋음 - 언더스코어를 사용한다.
string tablename;   // 좋음 - 모두 소문자이다.</pre></div>
        <div class=""><pre class="badcode">string tableName;   // 불가 - 대문자 사용</pre></div>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">클래스 데이터 멤버</span>
        </p><p>
          데이터 멤버(인스턴스 변수 또는 멤버 변수)의 이름은 보통 변수처럼
          소문자와 선택적인 언더스코어로 작성하지만, 항상 끝에 언더스코어를
          붙인다.
        </p>
        <div class=""><pre>string table_name_;  // 좋음 - 끝에 언더스코어가 있다.
string tablename_;   // 좋음</pre></div>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">구조체 변수</span>
        </p><p>
          구조체에 안에 있는 데이터 멤버는 클래스에 있는 데이터 멤버와 다르게
          끝에 언더스코어를 붙이지 않고 보통 변수처럼 이름짓는다.
        </p>
        <div class=""><pre>struct UrlTableProperties {
  string name;
  int num_entries;
}</pre></div>
        <p>
          어떤 경우에 클래스와 구조체를 써야 할 지에 대해서는
          <a href="#%EA%B5%AC%EC%A1%B0%EC%B2%B4_%EB%8C%80_%ED%81%B4%EB%9E%98%EC%8A%A4">구조체 대 클래스</a>를 참고하라.
        </p>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">전역 변수</span>
        </p><p>
          제한적으로 사용되어야 하는 전역 변수의 이름에 대한 특별한 규칙은 없다.
          하지만 전역 변수를 사용할 때에는 <code>g_</code>와 같이 로컬 변수와
          쉽게 구분할 수 있는 접두어를 사용하는 것이 좋다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84" id="상수_이름">상수 이름</a></h3>
<span class="link_button" id="link-상수_이름__button" name="link-상수_이름__button"><a href="?showone=%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84#%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('상수_이름')" name="상수_이름__button" id="상수_이름__button">▶</span>
    <div style="display:inline;" class="">
      <code>k</code>로 시작하는 대소문자가 섞인 이름을 사용한다. 예를 들면
      <code>kDaysInAWeek</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="상수_이름__body" id="상수_이름__body" style="display: none">
      <p>
        지역변수인지, 전역변수인지, 클래스의 일부인지와 상관 없이 모든 컴파일
        시점 상수들은 다른 변수들과 조금 다른 이름 규칙을 사용한다.
        <code>k</code>로 시작하여 매 단어의 첫 글자를 대문자로 쓴다.
      </p>
      <div class=""><pre>const int kDaysInAWeek = 7;</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%EC%9D%B4%EB%A6%84" id="함수_이름">함수 이름</a></h3>
<span class="link_button" id="link-함수_이름__button" name="link-함수_이름__button"><a href="?showone=%ED%95%A8%EC%88%98_%EC%9D%B4%EB%A6%84#%ED%95%A8%EC%88%98_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_이름')" name="함수_이름__button" id="함수_이름__button">▶</span>
    <div style="display:inline;" class="">
      일반 함수들은 대소문자가 섞인 방식을 사용한다. 접근자와 변경자는 해당하는
      변수의 이름과 같은 것을 쓴다. <code>MyExcitingFunction()</code>,
      <code>MyExcitingMethod()</code>,
      <code>my_exciting_member_variable()</code>,
      <code>set_my_exciting_member_variable()</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_이름__body" id="함수_이름__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">일반 함수</span>
        </p><p>
          함수 이름은 대문자로 시작하여 각 단어의 첫 글자를 대문자로 쓰고,
          언더스코어는 사용하지 않는다.
        </p>
        <p>
          함수의 실행 중 크래시가 발생할 수 있다면 함수의 이름 뒤에 OrDie 를
          붙인다. 이 규칙은 프로덕션 코드에서도 에러가 발생할 가능성이 어느 정도
          있는 함수에 한해 적용한다.
        </p>
        <div class=""><pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()</pre></div>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">접근자와 변경자</span>
        </p><p>
          접근자와 변경자 (get 과 set 함수)는 접근 또는 변경을 하려는 변수의
          이름과 일치하는 이름을 사용한다. 다음 예제는
          <code>num_entries_</code>라는 인스턴스 변수가 포함된 클래스의
          일부분이다.
        </p>
        <div class=""><pre>class MyClass {
 public:
  ...
  int num_entries() const { return num_entries_; }
  void set_num_entries(int num_entries) { num_entries_ = num_entries; }

 private:
  int num_entries_;
};</pre></div>
        <p>
          아주 짧은 인라인 함수에선 소문자를 사용할 수 있다. 예를 들어 
          리턴값을 캐시하지 않고 루프 안에서 호출할 정도로 가벼운 함수라면
          소문자 이름을 사용할 수 있다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EC%9D%B4%EB%A6%84" id="네임스페이스_이름">네임스페이스 이름</a></h3>
<span class="link_button" id="link-네임스페이스_이름__button" name="link-네임스페이스_이름__button"><a href="?showone=%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EC%9D%B4%EB%A6%84#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('네임스페이스_이름')" name="네임스페이스_이름__button" id="네임스페이스_이름__button">▶</span>
    <div style="display:inline;" class="">
      네임스페이스 이름은 모두 소문자로 하며, 프로젝트의 이름과 아마도
      디렉터리 구조에 기반하여 작성한다. 예를 들면
      <code>google_awesome_project</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="네임스페이스_이름__body" id="네임스페이스_이름__body" style="display: none">
      <p>
        네임스페이스와 네임스페이스의 이름을 짓는 방식에 대해선
        <a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a>를 참고하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%97%B4%EA%B1%B0%ED%98%95_%EC%9D%B4%EB%A6%84" id="열거형_이름">열거형 이름</a></h3>
<span class="link_button" id="link-열거형_이름__button" name="link-열거형_이름__button"><a href="?showone=%EC%97%B4%EA%B1%B0%ED%98%95_%EC%9D%B4%EB%A6%84#%EC%97%B4%EA%B1%B0%ED%98%95_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('열거형_이름')" name="열거형_이름__button" id="열거형_이름__button">▶</span>
    <div style="display:inline;" class="">
      열거형은 <a href="#%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84">상수</a> 또는
      <a href="#%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84">매크로</a> 방식 중 하나로 작성한다.
      <code>kEnumName</code> 또는 <code>ENUM_NAME</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="열거형_이름__body" id="열거형_이름__body" style="display: none">
      <p>
        각각의 열거형 값은 <a href="#%EC%83%81%EC%88%98_%EC%9D%B4%EB%A6%84">상수</a>처럼 이름짓는
        것이 선호되지만 <a href="#%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84">매크로</a>처럼 이름짓는
        것도 허용한다. 열거형의 이름 (예: <code>UrlTableErrors</code>,
        <code>AlternateUrlTableErrors</code>)은 타입이므로 대소문자를 섞어서
        사용한다.
      </p>
      <div class=""><pre>enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};</pre></div>
      <p>
        2009년 1월까지 열거형 값의 스타일은 <a href="#%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84">매크로</a>
        방식이었다. 이 방식은 매크로와 열거형 값의 충돌을 일으켰고,
        상수 스타일의 이름을 선호하는 방식으로 규칙이 변경되었다.
        새로 작성되는 코드는 상수 방식의 이름을 사용하는 것이 좋으나,
        이전 방식의 이름이 실제로 컴파일 오류를 발생시키는 것이 아니라면
        이전의 코드를 상수 스타일 이름으로 수정할 필요는 없다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84" id="매크로_이름">매크로 이름</a></h3>
<span class="link_button" id="link-매크로_이름__button" name="link-매크로_이름__button"><a href="?showone=%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84#%EB%A7%A4%ED%81%AC%EB%A1%9C_%EC%9D%B4%EB%A6%84">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('매크로_이름')" name="매크로_이름__button" id="매크로_이름__button">▶</span>
    <div style="display:inline;" class="">
      정말로 <a href="#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C">매크로를 정의</a>하려고 하는가?
      그렇다면 다음과 같이 하라.
      <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.
    </div>
    <div class=""><div class="stylepoint_body" name="매크로_이름__body" id="매크로_이름__body" style="display: none">
      <p>
        <a href="#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EB%A7%A4%ED%81%AC%EB%A1%9C">전처리기 매크로</a>를 참고하라.
        일반적으로 매크로는 사용하지 <em>않는</em> 것이 좋다.
        하지만 절대적으로 필요하다면 대문자와 언더스코어로만 이름을 짓는다.
      </p>
      <div class=""><pre>#define ROUND(x) ...
#define PI_ROUNDED 3.0</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99%EC%9D%98_%EC%98%88%EC%99%B8" id="이름_규칙의_예외">이름 규칙의 예외</a></h3>
<span class="link_button" id="link-이름_규칙의_예외__button" name="link-이름_규칙의_예외__button"><a href="?showone=%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99%EC%9D%98_%EC%98%88%EC%99%B8#%EC%9D%B4%EB%A6%84_%EA%B7%9C%EC%B9%99%EC%9D%98_%EC%98%88%EC%99%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('이름_규칙의_예외')" name="이름_규칙의_예외__button" id="이름_규칙의_예외__button">▶</span>
    <div style="display:inline;" class="">
      이미 존재하는 C 또는 C++ 엔티티와 비슷한 것의 이름을 짓는 경우
      그 이름 규칙을 따를 수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="이름_규칙의_예외__body" id="이름_규칙의_예외__body" style="display: none">
      <p>
        </p><dl>
          <dt> <code>bigopen()</code> </dt>
          <dd>   <code>open()</code>의 이름에 기반한 함수 </dd>
          <dt> <code>uint</code> </dt>
          <dd>   <code>typedef</code> </dd>
          <dt> <code>bigpos</code> </dt>
          <dd>   <code>pos</code>와 같은 형식의 <code>struct</code> 또는
                 <code>class</code>
</dd>
          <dt> <code>sparse_hash_map</code> </dt>
          <dd>   STL과 유사한 엔티티이므로 STL의 이름 규칙을 따름 </dd>
          <dt> <code>LONGLONG_MAX</code> </dt>
          <dd>  <code>INT_MAX</code>와 비슷한 상수 </dd>
        </dl>
      <p></p>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="주석" id="주석">주석</h2>
  <p>
    작성하는 것이 쉽지 않지만, 주석은 코드의 가독성을 유지하는 데 절대적으로
    중요한 역할을 한다. 다음 규칙은 어디에 무엇을 주석으로 달아야 할 지를
    설명한다. 하지만 기억할 점은 주석은 매우 중요하지만, 가장 좋은 코드는
    스스로에 대해 설명을 할 수 있는 코드라는 것이다. 타입과 변수에 이해할 수
    있는 이름을 짓는 것이 이상한 이름을 짓고 주석으로 설명하는 것보다 훨씬
    좋다.
  </p>
  <p>
    주석을 작성할 때에는 주석을 읽는 이를 위해서, 즉 그 코드를 보고 이해해야
    하는 다음 작업자를 위해 작성하라. 
    관대함을 가지라 - 다음 작업자는 본인일 수도 있다!
  </p>

  <div class="">
<h3><a name="%EC%A3%BC%EC%84%9D_%EC%8A%A4%ED%83%80%EC%9D%BC" id="주석_스타일">주석 스타일</a></h3>
<span class="link_button" id="link-주석_스타일__button" name="link-주석_스타일__button"><a href="?showone=%EC%A3%BC%EC%84%9D_%EC%8A%A4%ED%83%80%EC%9D%BC#%EC%A3%BC%EC%84%9D_%EC%8A%A4%ED%83%80%EC%9D%BC">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('주석_스타일')" name="주석_스타일__button" id="주석_스타일__button">▶</span>
    <div style="display:inline;" class="">
      일관성 있게 <code>//</code> 또는 <code>/* */</code> 문법을 사용한다.
    </div>
    <div class=""><div class="stylepoint_body" name="주석_스타일__body" id="주석_스타일__body" style="display: none">
      <p>
        <code>//</code>와 <code>/* */</code>의 사용이 모두 허용되지만,
        <code>//</code>이 <em>아주</em> 많이 사용된다.
        주석의 내용과 위치, 작성 방식에 일관성이 있어야 한다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%8C%8C%EC%9D%BC_%EC%A3%BC%EC%84%9D" id="파일_주석">파일 주석</a></h3>
<span class="link_button" id="link-파일_주석__button" name="link-파일_주석__button"><a href="?showone=%ED%8C%8C%EC%9D%BC_%EC%A3%BC%EC%84%9D#%ED%8C%8C%EC%9D%BC_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('파일_주석')" name="파일_주석__button" id="파일_주석__button">▶</span>
    <div style="display:inline;" class="">
      모든 파일의 시작 부분에는 라이선스 문안이 있어야 하고, 그 뒤에 내용에 대한
      설명이 있어야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="파일_주석__body" id="파일_주석__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">법적 고지와 작성자 목록</span>
        </p><p>
          모든 파일은 라이선스 문안을 포함해야 한다.
          프로젝트에서 사용하는 적절한 라이선스 문안을 선택하라.
          (예: Apache 2.0, BSD, LGPL, GPL).
        </p>
        <p>
          만약 작성자 목록이 있는 파일에 상당한 변경을 한 경우,
          작성자 목록을 삭제할 것을 고려하라.
        </p>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">파일 내용</span>
        </p><p>
          모든 파일의 위쪽에는 파일의 내용을 설명하는 주석이 포함되어야 한다.
        </p>
        <p>
          일반적으로 <code>.h</code> 파일은 그 파일 안에 정의된
          클래스에 대한 설명와 그 클래스가 어떻게 사용되는지에 대한
          설명을 포함해야 한다. <code>.cc</code> 파일은 구현에 대한
          세부사항이나 다루기 힘든 알고리즘에 대한 논의를 담아야 한다.
          구현 세부사항이나 알고리즘에 대한 논의가 <code>.h</code> 파일을
          읽는 사람에게도 필요하다고 생각하면 헤더 파일에 넣을 수도 있으나,
          <code>.cc</code>에도 이에 대한 문서가 <code>.h</code> 파일에 있다는
          것을 명시해야 한다.
        </p>
        <p>
          <code>.h</code>와 <code>.cc</code>에 중복하여 주석을 사용하지 말라.
          중복된 주석은 서로 다르게 변화할 것이다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%81%B4%EB%9E%98%EC%8A%A4_%EC%A3%BC%EC%84%9D" id="클래스_주석">클래스 주석</a></h3>
<span class="link_button" id="link-클래스_주석__button" name="link-클래스_주석__button"><a href="?showone=%ED%81%B4%EB%9E%98%EC%8A%A4_%EC%A3%BC%EC%84%9D#%ED%81%B4%EB%9E%98%EC%8A%A4_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('클래스_주석')" name="클래스_주석__button" id="클래스_주석__button">▶</span>
    <div style="display:inline;" class="">
      모든 클래스 정의는 그것이 무엇이고 어떻게 사용하는 지 설명하는, 클래스에
      수반하는 주석을 가져야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="클래스_주석__body" id="클래스_주석__body" style="display: none">
      <div class=""><pre>// GargantuanTable의 내용을 이터레이트한다.  용례:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};</pre></div>
      <p>
        이미 파일 상단의 주석에 클래스에 대한 상세한 설명을 두었다면,
        "전체 설명을 보기 위해서 파일 상단을 보라"라고 부담 없이 적어도 된다.
        단 어떤 형태로든 주석이 있어야 한다.
      </p>
      <p>
        클래스가 가정하고 있는 동기화 가정이 있는 경우 그것을 설명하라. 만약
        클래스의 인스턴스에 여러 개의 스레드에서 접근할 수 있는 경우, 멀티
        스레드 사용을 둘러싼 규칙과 변하지 않는 사항을 설명하는 데 특별히
        주의를 기울이라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%EC%A3%BC%EC%84%9D" id="함수_주석">함수 주석</a></h3>
<span class="link_button" id="link-함수_주석__button" name="link-함수_주석__button"><a href="?showone=%ED%95%A8%EC%88%98_%EC%A3%BC%EC%84%9D#%ED%95%A8%EC%88%98_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_주석')" name="함수_주석__button" id="함수_주석__button">▶</span>
    <div style="display:inline;" class="">
      선언 주석은 함수의 사용을 설명한다. 함수 정의의 주석은 함수의 동작을
      설명한다.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_주석__body" id="함수_주석__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">함수 선언</span>
        </p><p>
          모든 함수 선언은 그 함수가 무엇이고 어떻게 사용하는지 설명하는, 바로
          직전에 위치한 주석을 가져야 한다. 이 주석은 명령문("파일을 열어라")이
          아니라 설명문("파일을 연다")이어야 한다. 주석은 함수를 설명하는 것이지,
          함수에게 무엇을 하라고 말하는 것이 아니다. 보통 이 주석은 함수가 어떻게 그
          작업을 수행하는지 설명하지 않는다. 대신 이 내용은 함수 정의의 주석에게
          넘겨져야 한다.
        </p>
        <p>
          함수 선언의 주석에서 언급되어야 하는 것들의 유형은
        </p>
        <ul>
          <li> 입력은 무엇이고 출력은 무엇인지.
               </li>
          <li> 클래스 멤버 함수의 경우 객체가 레퍼런스 인자를 메서드 호출이
               끝난 후에도 기억하는지, 객체가 레퍼런스 인자를 해제하는지,
               해제하지 않는지.
               </li>
          <li> 함수가 메모리를 할당하는 경우, 호출자가 해제해야 하는지.
               </li>
          <li> 인자 중 어떤 것이 null 포인터일 수 있는지.
               </li>
          <li> 함수가 사용에 있어 어떤 성능 상의 영향이 있는 경우.
               </li>
          <li> re-entrant한 함수의 경우 동기화에 대한 가정이 무엇인지.
               </li>
        </ul>
        <p>
          예제는 아래와 같다.
        </p>
        <div class=""><pre>// 이 테이블에 대한 이터레이터를 반환한다. 사용이 끝난 후 이터레이터
// 삭제는 클라이언트의 책임이며, 이터레이터가 만들어진
// GargantuanTable 객체가 삭제된 후 이터레이터를 사용하면 안 된다.
//
// 이터레이터는 최초에 테이블의 시작에 위치한다.
//
// 이 메서드는 아래와 동일하다.
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek("");
//    return iter;
// 반환된 이터레이터와 다른 장소를 즉시 찾고자 하는 경우,
// NewIterator()를 사용하면 더 빠르고, 추가로 검색이 일어나지 않는다.
Iterator* GetIterator() const;</pre></div>
        <p>
          하지만 필요 이상으로 자세하거나 완벽하게 명백하도록 서술하지 말라.
          아래에서 "그렇지 않은 경우 <code>false</code>를 반환한다"고 말하는
          것은 이미 함축된 것이기에 불필요하다는 점에 주목하라.
        </p>
        <div class=""><pre>// 테이블이 더 이상 엔트리를 가질 수 없을 때 true를 반환한다.
bool IsTableFull();</pre></div>
        <p>
          생성자와 소멸자에 주석을 달 때, 그 코드를 읽는 사람은 생성자와
          소멸자가 무엇을 위한 것인지 알고 있음을 기억하라. 그러므로 단지 "이
          객체를 소멸시킨다" 따위의 것을 쓰는 것은 쓸모가 없다. 생성자가 그의
          인자로 무엇을 하는지 설명하고 (예를 들면 그들이 포인터의 소유권을
          가지는 경우), 소멸자가 무엇을 해제하는 지 설명하라. 설명이 사소한 경우
          그냥 주석을 생략하라. 소멸자가 헤더 주석을 가지지 않는 경우는
          상당히 흔하다.
        </p>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">함수 정의</span>
        </p><p>
          함수가 작업을 수행하는 방법 상 까다로운 부분이 있는 경우, 함수 정의가
          설명하는 주석을 가져야 한다. 예를 들면 그 코드에서 사용하는 코딩 비결을
          설명하거나, 함수 안에서 수행하는 작업 절차에 대한 개요를 제시하거나, 왜
          가능한 다른 대안을 사용하지 않고 특정한 방식으로 함수를 구현했는지
          함수 정의에서 설명할 수 있다. 예를 들면 함수의 전반부에는 lock을
          획득하지만 후반부에서는 lock이 필요없는 이유를 언급할 수 있다.
        </p>
        <p>
          <code>.h</code> 파일이나 혹은 어딘가에 있을, 함수 선언의 주석을 단지
          반복하지 <em>않아야</em> 하는 데 주목하라. 함수가 무엇을 하는지
          요약하여 요점을 되풀이하는 것은 문제 없으나, 주석의 요점은 함수가
          그것을 어떻게 수행하느냐에 대한 것이어야 한다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B3%80%EC%88%98_%EC%A3%BC%EC%84%9D" id="변수_주석">변수 주석</a></h3>
<span class="link_button" id="link-변수_주석__button" name="link-변수_주석__button"><a href="?showone=%EB%B3%80%EC%88%98_%EC%A3%BC%EC%84%9D#%EB%B3%80%EC%88%98_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('변수_주석')" name="변수_주석__button" id="변수_주석__button">▶</span>
    <div style="display:inline;" class="">
      일반적으로 변수의 실제 이름은 그 변수가 무엇을 위한 것인지 알아채기 쉽도록
      설명적이어야 한다. 어떤 경우에는 더 많은 주석이 필요하다.
    </div>
    <div class=""><div class="stylepoint_body" name="변수_주석__body" id="변수_주석__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">클래스 데이터 멤버</span>
        </p><p>
          (인스턴스 변수나 멤버 변수라고도 불리는) 각각의 클래스 데이터 멤버는
          그것이 무엇을 위한 것인지 설명하는 주석을 가져야 한다. 만약 변수가
          <code>null</code> 포인터나 <code>-1</code>과 같은, 특별한 의미의
          표식 값을 가질 수 있는 경우 이를 설명해야 한다. 예를 들면,
        </p>
        <div class=""><pre>private:
 // 테이블에 있는 엔트리의 총 개수를 기록한다.
 // 한계를 넘지 않도록 보장하는 데 사용된다. -1은 테이블에 얼마나 많은
 // 엔트리가 들어있는지 아직 알지 못하는 경우를 의미한다.
 int num_total_entries_;</pre></div>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">전역 변수</span>
        </p><p>
          데이터 멤버와 마찬가지로, 모든 전역 변수는 그것이 무엇이며 어디에
          사용되는지 설명하는 주석을 가져야 한다.
          예를 들면,
        </p>
        <div class=""><pre>// 이 회귀 테스트에서 통과한 테스트 케이스의 총 개수
const int kNumTestCases = 6;</pre></div>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EA%B5%AC%ED%98%84_%EC%A3%BC%EC%84%9D" id="구현_주석">구현 주석</a></h3>
<span class="link_button" id="link-구현_주석__button" name="link-구현_주석__button"><a href="?showone=%EA%B5%AC%ED%98%84_%EC%A3%BC%EC%84%9D#%EA%B5%AC%ED%98%84_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('구현_주석')" name="구현_주석__button" id="구현_주석__button">▶</span>
    <div style="display:inline;" class="">
      구현에서 까다롭거나, 명백하지 않거나, 흥미롭거나, 중요한 부분은
      주석을 가져야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="구현_주석__body" id="구현_주석__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">클래스 데이터 멤버</span>
        </p><p>
          까다롭거나 복잡한 코드 조각은 그 앞에 주석을 포함해야 한다. 예를 들면,
        </p>
        <div class=""><pre>// 덧셈에서 생긴 carry를 고려하여 결과를 2로 나눈다.
// (역자 주: 큰 숫자를 2로 나누는 알고리즘으로 나눗셈을 비트 연산으로
// 처리하되 나눠지지 않는 큰 숫자의 나머지를 carry로 보아 다음
// 나눗셈에 해당하는 비트 연산으로 전달하는 코드이다.)
for (int i = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">줄 주석</span>
        </p><p>
          또한 명백하지 않은 부분도 줄 끝에 주석을 가져야 한다. 이러한 줄 끝
          주석은 2개의 스페이스 문자로 코드에서 분리되어야 한다. 예를 들면,
        </p>
        <div class=""><pre>// 충분한 메모리가 있는 경우, 데이터 부분도 mmap으로 처리한다.
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // 오류는 이미 로그에 기록되었다.</pre></div>
        <p>
          코드가 무엇을 하고 있는지 설명하는 주석과 함수가 리턴할 때 오류가 이미
          로그에 기록되었음을 언급하는 주석이 모두 있음에 주목하라.
        </p>
        <p>
          다음 줄에 여러 주석이 있는 경우, 종종 이들을 일렬로 세우는 것이 더
          읽기 쉬울 수 있다.
        </p>
        <div class=""><pre>DoSomething();                  // 주석을 일렬로 세우기 위해 여기에 주석을 둔다.
DoSomethingElseThatIsLonger();  // 코드와 주석 사이에 두 스페이스가 있기 때문에
                                // 여기에 주석을 둔다.
{ // 새 범위가 시작될 경우 주석 앞에 스페이스를 하나 두는 것이 허용되고,
  // 이에 따라 따라오는 주석과 코드에 일렬로 세워진다.
  DoSomethingElse();  // 줄 주석의 앞에는 보통 두 개의 스페이스
}
DoSomething(); /* 뒤따르는 블럭 주석에는 하나의 스페이스면 충분하다. */</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">nullptr/NULL, true/false, 1, 2, 3...</span>
        </p><p>
          null 포인터나 불리언 혹은 문자로 된 숫자 값을 함수에 전달할 때, 
          그것들이 무엇인지에 관해 주석을 추가하거나 상수를
          사용하여 코드가 스스로 설명될 수 있게 만들어야 한다. 예를
          들자면 아래를 비교해 보라.
        </p>
        <div class=""><pre class="badcode">bool success = CalculateSomething(interesting_value,
                                  10,
                                  false,
                                  NULL);  // 이 인자들은 무엇일까?</pre></div>
        <p>
          대:
        </p>
        <div class=""><pre>bool success = CalculateSomething(interesting_value,
                                  10,     // 디폴트 기본값.
                                  false,  // 호출이 최초가 아님.
                                  NULL);  // 콜백 없음.</pre></div>
        <p>
          그렇지 않다면, 스스로 설명할 수 있는 변수나 상수들:
        </p>
        <div class=""><pre>const int kDefaultBaseValue = 10;
const bool kFirstTimeCalling = false;
Callback *null_callback = NULL;
bool success = CalculateSomething(interesting_value,
                                  kDefaultBaseValue,
                                  kFirstTimeCalling,
                                  null_callback);</pre></div>
      <p></p>

      <p class="">
<span class="stylepoint_subsection">하지 말 것</span>
        </p><p>
          <em>절대로</em> 코드 그 자체를 설명하지 말아야 한다는 데 주목하라.
          코드를 읽는 사람이 코드의 의도를 모름에도 불구하고 코드 작성자보다
          C++을 더 잘 알고 있다고 가정하라.
        </p>
        <div class=""><pre class="badcode">// 이제 b 배열을 통과하는데 만약 i가 있다면 다음 요소는 i+1임이 확실하다.
...        // 이런, 이 얼마나 쓸데없는 주석인가.</pre></div>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EA%B5%AC%EB%91%90%EC%A0%90,_%EC%B2%A0%EC%9E%90,_%EB%AC%B8%EB%B2%95" id="구두점,_철자,_문법">구두점, 철자, 문법</a></h3>
<span class="link_button" id="link-구두점,_철자,_문법__button" name="link-구두점,_철자,_문법__button"><a href="?showone=%EA%B5%AC%EB%91%90%EC%A0%90,_%EC%B2%A0%EC%9E%90,_%EB%AC%B8%EB%B2%95#%EA%B5%AC%EB%91%90%EC%A0%90,_%EC%B2%A0%EC%9E%90,_%EB%AC%B8%EB%B2%95">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('구두점,_철자,_문법')" name="구두점,_철자,_문법__button" id="구두점,_철자,_문법__button">▶</span>
    <div style="display:inline;" class="">
      구두점, 철자, 문법에 주의하라. 구두점, 철자, 문법이 제대로
      사용된 주석이 이해하기 쉽다.
    </div>
    <div class=""><div class="stylepoint_body" name="구두점,_철자,_문법__body" id="구두점,_철자,_문법__body" style="display: none">
      <p>
        주석은 일반적인 문장과 마찬가지로 읽기가 쉬워야 하고, 적절한 대소문자와
        구두점이 사용되어야 한다. 대부분의 경우 완전한 문장이 파편화된 문장에 비해
        이해하기가 쉽다. 코드 라인의 끝에 사용되는 주석은 격식을 갖추지
        못할 수도 있지만 일관성은 있어야 한다.
      </p>
      <p>
        세미콜론을 사용해야 할 자리에 콤마를 사용했다고 코드 리뷰어에게
        지적당하는 현실에 좌절할 수도 있지만, 소스코드는 높은 수준의 명확함과
        가독성을 유지해야 한다. 올바른 구두점, 철자, 문법의 사용은
        그 목표를 달성하는데 도움을 준다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="TODO_%EC%A3%BC%EC%84%9D" id="TODO_주석">TODO 주석</a></h3>
<span class="link_button" id="link-TODO_주석__button" name="link-TODO_주석__button"><a href="?showone=TODO_%EC%A3%BC%EC%84%9D#TODO_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('TODO_주석')" name="TODO_주석__button" id="TODO_주석__button">▶</span>
    <div style="display:inline;" class="">
      아직 완벽하지 않은 코드 혹은 임시적이고 단기적인 해결책에
      <code>TODO</code> 주석을 사용하라.
    </div>
    <div class=""><div class="stylepoint_body" name="TODO_주석__body" id="TODO_주석__body" style="display: none">
      <p>
        <code>TODO</code> 주석에서 <code>TODO</code>는 모두 대문자로
        해야 하며, 이름, 이메일 혹은 다른 종류의 작성자를 판별할 수 있는
        방법을 제공하여 문제점을 문의할 수 있도록 해야 한다. 콜론은 선택적으로
        사용할 수 있다. 일관성 있는 <code>TODO</code> 포맷을 사용하여 필요할 때
        올바른 상황 설명을 해 줄 사람을 찾을 수 있게 하는 것이 주 목적이다.
        <code>TODO</code> 주석은 작성자가 그 문제를 고친다는 약속은 아니다.
        그러므로 <code>TODO</code> 주석에 언제나 이름을 포함하라.
      </p>

      <div class=""><pre>// TODO(kl@gmail.com): 연결 연산자로 "*"를 사용하라.
// TODO(Zeke) 연관 관계를 사용하도록 이 부분을 수정.</pre></div>
      <p>
        <code>TODO</code> 주석의 형태가 "미래에 무엇을 한다"라면,
        상세한 날짜를 남기거나 ("2005년 11월까지 수정"),
        상세한 이벤트를 기록하라 (모든 클라이언트가 XML 응답을 할 수 있게 되면
        삭제).
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="Deprecation_%EC%A3%BC%EC%84%9D" id="Deprecation_주석">Deprecation 주석</a></h3>
<span class="link_button" id="link-Deprecation_주석__button" name="link-Deprecation_주석__button"><a href="?showone=Deprecation_%EC%A3%BC%EC%84%9D#Deprecation_%EC%A3%BC%EC%84%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('Deprecation_주석')" name="Deprecation_주석__button" id="Deprecation_주석__button">▶</span>
    <div style="display:inline;" class="">
      Deprecate된 인터페이스는 <code>DEPRECATED</code> 주석으로 표시해 둔다.
    </div>
    <div class=""><div class="stylepoint_body" name="Deprecation_주석__body" id="Deprecation_주석__body" style="display: none">
      <p>
        <code>DEPRECATED</code> 를 모두 대문자로 쓴 주석을 사용하여
        deprecate된 인터페이스를 표시할 수 있다. 주석은 인터페이스가 선언된
        윗 라인이나 같은 라인에 쓰면 된다.
      </p>

      <p>
        <code>DEPRECATED</code> 뒤에 이름, 이메일 혹은 다른 식별자를 괄호 안에
        쓴다.
      </p>
      <p>
        <code>DEPRECATED</code> 주석은 호출측의 문제점을 수정할 수 있도록
        간결하고 명확하게 작성하여야 한다. C++에서는 deprecate된 함수를
        인라인으로 구현하여 새 인터페이스를 호출하게 할 수 있다.
      </p>
      <p>
        <code>DEPRECATED</code> 주석을 표시한다고 해서 호출 측의 문제가 자동으로
        수정되는 것은 아니다. 호출측의 코드를 직접 수정하거나 다른 사람을
        시켜서 deprecate된 인터페이스를 사용하지 않도록 조치를 취해야 한다.
      </p>
      <p>
        새로 작성하는 코드는 deprecate된 인터페이스를 사용하지 말고, 새로운
        인터페이스를 사용해야 한다. deprecate된 인터페이스를 대체할 인터페이스를
        모를 경우에는 deprecate 주석을 작성한 사람에게 새로운 인터페이스를
        문의해서 사용해야 한다.
      </p>

    </div></div>
  </div>

</div>

<div class="">
<h2 name="포매팅" id="포매팅">포매팅</h2>
  <p>
    코딩 스타일과 포매팅은 제멋대로인 경우가 많지만, 모두가 통일된 스타일을
    쓴다면 프로젝트를 파악하기가 훨씬 쉬워진다. 개개인이 모든 포매팅 규칙에 다
    동의하기는 어렵고, 어떤 규칙은 익숙해지는데 시간이 걸리지만, 프로젝트의
    구성원들이 규칙을 따라서 다른 사람의 코드를 쉽게 이해하도록 하는 것은
    중요하다.
  </p>

  <p>
    코드를 형식에 맞게 작성하는 것을 돕기 위해
    <a href="http://google-styleguide.googlecode.com/svn/trunk/google-c-style.el">emacs 설정파일</a>
    을 만들었다.
  </p>

  <div class="">
<h3><a name="%EC%A4%84_%EA%B8%B8%EC%9D%B4" id="줄_길이">줄 길이</a></h3>
<span class="link_button" id="link-줄_길이__button" name="link-줄_길이__button"><a href="?showone=%EC%A4%84_%EA%B8%B8%EC%9D%B4#%EC%A4%84_%EA%B8%B8%EC%9D%B4">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('줄_길이')" name="줄_길이__button" id="줄_길이__button">▶</span>
    <div style="display:inline;" class="">
      코드의 각 줄은 80 문자를 넘지 않게 하라.
    </div>
    <div class=""><div class="stylepoint_body" name="줄_길이__body" id="줄_길이__body" style="display: none">

      <p>
        이 규칙에 여러 이견이 있지만, 기존의 많은 코드들이 이미 이 규칙을
        따르고 있고, 우리는 일관성이 중요하다고 생각한다.
      </p>
      <p class="">
<span class="stylepoint_section">장점:  </span>
        이 규칙을 좋아하는 사람들은 창 크기를 조절해야 하는 상황에 반감을 가지고
        있고, 그보다 더 길어질 이유가 없다고 생각한다. 어떤 사람들은 여러 코드
        창을 나란히 붙이는 환경에 익숙해서 어떤 경우에도 화면의 너비를 넓힐
        공간이 없다. 사람들은 자신의 작업 환경을 특정 최대 창 너비를 가정하여
        설정하고, 길이 80자는 전통적인 표준이다. 바꿀 이유가 없다.
      </p>
      <p class="">
<span class="stylepoint_section">단점: </span>
        변화를 지지하는 사람들은 더 긴 라인이 가독성을 좋게 한다고 주장한다.
        최근의 장비는 더 긴 라인을 쉽게 보여줄 수 있는 넓은 화면을 가지고 있기에
        80 문자 규칙은 1960년대의 메인프레임 시절로 돌아가는 완고한 시대 착오이다.
      </p>
      <p class="">
<span class="stylepoint_section">결론:  </span>
        </p><p>
          80 문자가 최대이다.
        </p>
        <p>
          예외: 주석이 명령어 예시 또는 80 문자를 넘는 URL을 포함한다면
          그 줄은 80 문자를 넘을 수 있다. 이것은 잘라내기와 붙여넣기를
          쉽게 하기 때문이다.
        </p>
        <p>
          예외: 긴 경로를 가진 <code>#include</code> 문은 80 문자를 넘을 수
          있다. 이런 경우가 필요하지 않도록 노력하라.
        </p>
        <p>
          예외: <a href="#_define_%EA%B0%80%EB%93%9C">헤더의 가드</a> 는 최대 길이의
          제한을 고려하지 않아도 된다.
        </p>
      <p></p>
    </div></div>
  </div>

  <div class="">
<h3><a name="ASCII%EA%B0%80_%EC%95%84%EB%8B%8C_%EB%AC%B8%EC%9E%90" id="ASCII가_아닌_문자">ASCII가 아닌 문자</a></h3>
<span class="link_button" id="link-ASCII가_아닌_문자__button" name="link-ASCII가_아닌_문자__button"><a href="?showone=ASCII%EA%B0%80_%EC%95%84%EB%8B%8C_%EB%AC%B8%EC%9E%90#ASCII%EA%B0%80_%EC%95%84%EB%8B%8C_%EB%AC%B8%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('ASCII가_아닌_문자')" name="ASCII가_아닌_문자__button" id="ASCII가_아닌_문자__button">▶</span>
    <div style="display:inline;" class="">
      ASCII가 아닌 문자는 자주 사용하지 않아야 하며, 반드시 UTF-8 포매팅을
      사용해야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="ASCII가_아닌_문자__body" id="ASCII가_아닌_문자__body" style="display: none">
      <p>
        설사 영어라 할 지라도 소스 코드에서 사용자가 보게 되는 글자들을
        하드 코딩하지 않아야 한다. 그래서 ASCII가 아닌 문자를 자주 사용하지
        않아야 한다. 그러나 어떤 경우 코드에 이러한 ASCII가 아닌 문자를
        포함하는 것이 적절할 수 있다. 예를 들면, 외국어로 된 데이터 파일을
        파싱하는 경우, 그 데이터 파일에서 구분자로 사용한 ASCII가 아닌 문자열을
        하드 코딩하는 것이 적절할 수 있다. 더 일반적으로, (다국어화가 필요 없는)
        유닛테스트 코드는 ASCII가 아닌 문자열을 포함할 수 있다. 그런 경우
        ASCII 이상을 지원하는 대부분의 도구들이 이해하는 인코딩인 UTF-8을
        사용해야 한다.
      </p>
      <p>
        헥사 인코딩도 가독성을 좋게 하는 곳이라면 써도 좋다. 예를 들면
        <code>"\xEF\xBB\xBF"</code>나, 더 간단하게 <code>u8"\uFEFF"</code>는
        길이가 0이고 줄 바꿈이 없는 유니코드 공백 문자로 UTF-8로 소스에
        포함된다면 보이지 않을 것이다.
      </p>
      <p>
        <code>\uXXXX</code> 이스케이프 시퀀스를 포함한 문자열이 UTF-8로
        인코딩되었음을 보증하기 위해 <code>u8</code> 접두어를 사용하라. UTF-8로
        인코딩된 ASCII가 아닌 문자들을 포함한 문자열에는 이 접두어를 사용하지
        말라. 컴파일러가 소스 파일을 UTF-8로 해석하지 않을 경우 잘못된
        결과를 내놓을 수 있기 때문이다.
      </p>
      <p>
        C++11의 <code>char16_t</code>와 <code>char32_t</code>를 사용하지 말라.
        이것들은 UTF-8이 아닌 문자를 지원하기 위한 것들이다. 비슷한 이유로
        (<code>wchar_t</code>를 광범위하게 사용하고 있는 윈도우 API를 사용하는
        코드를 작성하는 것이 아니라면) <code>wchar_t</code>를 사용하지 말라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%8C%80_%ED%83%AD" id="스페이스_대_탭">스페이스 대 탭</a></h3>
<span class="link_button" id="link-스페이스_대_탭__button" name="link-스페이스_대_탭__button"><a href="?showone=%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%8C%80_%ED%83%AD#%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%8C%80_%ED%83%AD">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('스페이스_대_탭')" name="스페이스_대_탭__button" id="스페이스_대_탭__button">▶</span>
    <div style="display:inline;" class="">
      스페이스만 사용하고 2개의 스페이스로 들여쓰기 하라.
    </div>
    <div class=""><div class="stylepoint_body" name="스페이스_대_탭__body" id="스페이스_대_탭__body" style="display: none">
      <p>
        들여쓰기를 위해 스페이스를 사용한다. 코드에서 탭을 사용하지 말라.
        탭을 눌렀을 때 스페이스를 입력하도록 편집기를 설정하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%EC%84%A0%EC%96%B8%EA%B3%BC_%EC%A0%95%EC%9D%98" id="함수_선언과_정의">함수 선언과 정의</a></h3>
<span class="link_button" id="link-함수_선언과_정의__button" name="link-함수_선언과_정의__button"><a href="?showone=%ED%95%A8%EC%88%98_%EC%84%A0%EC%96%B8%EA%B3%BC_%EC%A0%95%EC%9D%98#%ED%95%A8%EC%88%98_%EC%84%A0%EC%96%B8%EA%B3%BC_%EC%A0%95%EC%9D%98">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_선언과_정의')" name="함수_선언과_정의__button" id="함수_선언과_정의__button">▶</span>
    <div style="display:inline;" class="">
      가능하면 리턴 타입과 함수 이름, 인자를 같은 줄에 작성하라.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_선언과_정의__body" id="함수_선언과_정의__body" style="display: none">
      <p>
        함수들은 이렇게
      </p>
      <div class=""><pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}</pre></div>
      <p>
        한 줄에 넣기에 글자가 너무 많다면
      </p>
      <div class=""><pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}</pre></div>
      <p>
        혹은 첫번째 인자도 맞추기 힘들다면
      </p>
      <div class=""><pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}</pre></div>
      <p>
        몇 가지 주의할 점
      </p>
      <ul>
        <li> 리턴 타입과 함수 이름을 한 줄에 적을 수 없다면, 그 사이를
             줄바꿈하라.
             </li>
        <li> 함수 정의의 리턴 타입 뒤에 줄바꿈을 한다면,
             들여쓰기를 하지 말라.
             </li>
        <li> 여는 괄호는 항상 함수 이름과 같은 줄에 작성하라.
             </li>
        <li> 함수 이름과 여는 괄호 사이에는 절대로 스페이스를 넣지 않는다.
             </li>
        <li> 괄호와 인자 사이에는 절대로 스페이스를 넣지 않는다.
             </li>
        <li> 여는 중괄호({)는 항상 마지막 인자와 같은 줄에 작성하라.
             </li>
        <li> 닫는 중괄호(})는 혼자 마지막 줄에 위치하거나, (다른 규칙들이
             허용한다면) 여는 중괄호와 같은 줄에 위치한다.
             </li>
        <li> 닫는 괄호와 여는 중괄호 사이에는 하나의 스페이스를 두라.
             </li>
        <li> 모든 인자는 이름을 가져야 하며, 선언과 구현에서 같은 이름을 가지게
             하라.
             </li>
        <li> 모든 인자들은 가능한 한 정렬되어야 한다.
             </li>
        <li> 기본 들여쓰기는 2개의 스페이스이다.
             </li>
        <li> 인자들이 다음 줄로 이동할 경우 4개의 스페이스 들여쓰기를 사용한다.
             </li>
      </ul>
      <p>
        만약 몇몇 인자들이 사용되지 않으면, 함수 선언에서 변수 이름을
        주석처리하라.
      </p>
      <div class=""><pre>// 인터페이스에서는 항상 이름이 있는 인자를 가진다.
class Shape {
 public:
  virtual void Rotate(double radians) = 0;
}

// 선언에서 항상 이름이 있는 인자를 가진다.
class Circle : public Shape {
 public:
  virtual void Rotate(double radians);
}

// 정의에서 사용하지 않는 이름을 주석처리하라.
void Circle::Rotate(double /*radians*/) {}</pre></div>
      <div class=""><pre class="badcode">// 나쁨 - 누군가 나중에 구현을 하려고 하더라도,
// 변수가 무엇을 의미하는지 명확하게 알 수 없다.
void Circle::Rotate(double) {}</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%95%A8%EC%88%98_%ED%98%B8%EC%B6%9C" id="함수_호출">함수 호출</a></h3>
<span class="link_button" id="link-함수_호출__button" name="link-함수_호출__button"><a href="?showone=%ED%95%A8%EC%88%98_%ED%98%B8%EC%B6%9C#%ED%95%A8%EC%88%98_%ED%98%B8%EC%B6%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('함수_호출')" name="함수_호출__button" id="함수_호출__button">▶</span>
    <div style="display:inline;" class="">
      자리가 충분한 경우 한 줄에 쓰고, 그렇지 않은 경우 괄호 안의 인자들을
      줄바꿈한다.
    </div>
    <div class=""><div class="stylepoint_body" name="함수_호출__body" id="함수_호출__body" style="display: none">
      <p>
        함수 호출은 다음과 같은 형식으로 작성한다.
      </p>
      <div class=""><pre>bool retval = DoSomething(argument1, argument2, argument3);</pre></div>
      <p>
        인자들이 모두 한 줄에 들어갈 자리가 없다면 여러 줄로 나누어 쓰되
        이어지는 줄은 첫번째 인자와 같은 열에 오도록 한다.
        여는 괄호 다음과 닫는 괄호 앞에는 스페이스를 추가하지 않는다.
      </p>
      <div class=""><pre>bool retval = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);</pre></div>
      <p>
        함수의 인자가 많은 경우 가독성을 위해 인자마다 한 줄씩 쓰는 것을
        고려하라
      </p>
      <div class=""><pre>bool retval = DoSomething(argument1,
                          argument2,
                          argument3,
                          argument4);</pre></div>
      <p>
        모든 인자들마다 줄바꿈하여 한 줄에 하나씩 쓰는 것도 가능하다.
      </p>
      <div class=""><pre>if (...) {
  ...
  ...
  if (...) {
    DoSomething(
        argument1,  // 스페이스 4개로 들여쓰기
        argument2,
        argument3,
        argument4);
  }</pre></div>
      <p>
        특히 이 방식은 함수 시그너쳐가 길어서 최대
        <a href="#%EC%A4%84_%EA%B8%B8%EC%9D%B4">줄 길이</a>에 맞출 수 없을 때 사용하는 것이 좋다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A4%91%EA%B4%84%ED%98%B8_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8" id="중괄호_초기화_리스트">중괄호 초기화 리스트</a></h3>
<span class="link_button" id="link-중괄호_초기화_리스트__button" name="link-중괄호_초기화_리스트__button"><a href="?showone=%EC%A4%91%EA%B4%84%ED%98%B8_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8#%EC%A4%91%EA%B4%84%ED%98%B8_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('중괄호_초기화_리스트')" name="중괄호_초기화_리스트__button" id="중괄호_초기화_리스트__button">▶</span>
    <div style="display:inline;" class="">
      중괄호로 된 초기화 리스트는 함수 호출에서와 완전히 같은 방식으로 작성한다.
    </div>
    <div class=""><div class="stylepoint_body" name="중괄호_초기화_리스트__body" id="중괄호_초기화_리스트__body" style="display: none">
      <p>
        중괄호 리스트가 어떤 이름(타입이나 변수 이름)에 이어져서 사용되는 경우
        <code>{}</code>가 그 이름을 가진 함수를 호출하는 괄호인 것처럼
        작성한다. 만약 그러한 이름이 없으면 길이가 0인 이름이 있다고 가정한다.
      </p>
      <div class=""><pre>// 중괄호 초기화 리스트를 한 줄에 사용한 예
return {foo, bar};
functioncall({foo, bar});
pair&lt;int, int&gt; p{foo, bar};

// 줄바꿈을 해야 할 때
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // 여기선 { 다음에도 줄바꿈을 할 수 있다
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A1%B0%EA%B1%B4%EB%AC%B8" id="조건문">조건문</a></h3>
<span class="link_button" id="link-조건문__button" name="link-조건문__button"><a href="?showone=%EC%A1%B0%EA%B1%B4%EB%AC%B8#%EC%A1%B0%EA%B1%B4%EB%AC%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('조건문')" name="조건문__button" id="조건문__button">▶</span>
    <div style="display:inline;" class="">
      괄호 안에서는 스페이스를 사용하지 않을 것을 권장한다. <code>else</code>
      키워드는 새 줄에서 사용한다.
    </div>
    <div class=""><div class="stylepoint_body" name="조건문__body" id="조건문__body" style="display: none">
      <p>
        기본적인 조건문에는 두 가지의 허용가능한 포맷이 있다.
        첫 번째는 괄호 사이에 스페이스를 넣는 것이고 두 번째는 넣지 않는 것이다.
      </p>
      <p>
        가장 흔한 형식은 스페이스를 쓰지 않는 것이다. 두 가지 모두 괜찮으나,
        <em>일관되어야 한다.</em> 어떤 파일을 수정하고 있다면 그 파일에 이미
        사용되고 있는 형식을 사용하라. 새로운 코드를 작성하고 있다면 해당
        디렉터리나 프로젝트의 다른 파일에서 사용하고 있는 형식을 사용하라.
        이미 사용되고 있는 형식을 알 수 없고 개인적인 선호도 없는 경우
        스페이스를 넣지 말라.
      </p>
      <div class=""><pre>if (condition) {  // 괄호 안에 스페이스 없음
  ...  // 스페이스 2개 들여쓰기
} else if (...) {  // else문은 닫는 중괄호와 같은 줄에
  ...
} else {
  ...
}</pre></div>
      <p>
        만약 괄호 사이에 스페이스를 넣는 것을 선호한다면,
      </p>
      <div class=""><pre>if ( condition ) {  // 괄호 사이 스페이스
  ...  // 스페이스 2개 들여쓰기
} else {  // else문은 닫는 중괄호와 같은 줄에
  ...
}</pre></div>
      <p>
        모든 경우에 <code>if</code>와 여는 괄호 사이에는 스페이스 하나가
        있어야 한다. 중괄호를 사용하는 조건문의 경우 닫는 괄호와 중괄호
        사이에도 스페이스 하나를 사용해야 한다.
      </p>
      <div class=""><pre class="badcode">if(condition)     // 나쁨 - IF 뒤에 스페이스가 없음
if (condition){   // 나쁨 - { 앞에 스페이스가 없음
if(condition){    // 두 배로 나쁨</pre></div>
      <div class=""><pre>if (condition) {  // 좋음 - IF 뒤와 { 앞 모두 스페이스가 있음</pre></div>
      <p>
        짧은 조건문은 가독성을 향상시키는 경우 한 줄에 작성될 수 있다.
        조건문의 길이가 짧고 <code>else</code>를 사용하지 않는 경우에만 이
        방식을 사용할 수 있다.
      </p>
      <div class=""><pre>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();</pre></div>
      <p>
        <code>else</code>가 있으면 이 방식을 사용할 수 없다.
      </p>
      <div class=""><pre class="badcode">// 안됨 - ELSE 구문이 있는데도 IF 문을 한 줄에 사용했음
if (x) DoThis();
else DoThat();</pre></div>
      <p>
        일반적으로 한 줄짜리 구문의 경우 중괄호를 꼭 사용하지 않아도 되며,
        선호하는 경우 사용하여도 된다. 복잡한 조건이나 구문들로 이루어진
        조건문과 반복문의 경우 중괄호가 있을 때 가독성이 더 좋을 수 있다. 어떤
        프로젝트는 <code>if</code> 문에 항상 중괄호를 사용할 것을 요구하기도
        한다.
      </p>
      <div class=""><pre>if (condition)
  DoSomething();  // 스페이스 2개 들여쓰기

if (condition) {
  DoSomething();  // 스페이스 2개 들여쓰기
}</pre></div>
      <p>
        하지만 만약 <code>if</code>-<code>else</code> 문 중 한 쪽이 중괄호를
        사용하고 있다면 다른 쪽도 반드시 사용해야 한다.
      </p>
      <div class=""><pre class="badcode">// 안됨 - IF에는 중괄호가 있지만 ELSE에는 없음
if (condition) {
  foo;
} else
  bar;

// 안됨 - ELSE에는 중괄호가 있지만 IF에는 없음
if (condition)
  foo;
else {
  bar;
}</pre></div>
      <div class=""><pre>// 한 쪽에 중괄호를 사용하였으면 IF 와 ELSE 모두 중괄호가 있어야 함
if (condition) {
  foo;
} else {
  bar;
}</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B0%98%EB%B3%B5%EB%AC%B8%EA%B3%BC_switch_%EB%AC%B8" id="반복문과_switch_문">반복문과 switch 문</a></h3>
<span class="link_button" id="link-반복문과_switch_문__button" name="link-반복문과_switch_문__button"><a href="?showone=%EB%B0%98%EB%B3%B5%EB%AC%B8%EA%B3%BC_switch_%EB%AC%B8#%EB%B0%98%EB%B3%B5%EB%AC%B8%EA%B3%BC_switch_%EB%AC%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('반복문과_switch_문')" name="반복문과_switch_문__button" id="반복문과_switch_문__button">▶</span>
    <div style="display:inline;" class="">
      switch 문은 블록마다 중괄호를 사용할 수 있다. 단순하지 않게 이어지는
      case 문들은 주석을 달아야 한다. 비어 있는 반복문은 <code>{}</code> 또는
      <code>continue</code>를 사용해야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="반복문과_switch_문__body" id="반복문과_switch_문__body" style="display: none">
      <p>
        <code>switch</code>문의 <code>case</code> 블록은 선호에 따라 중괄호를
        사용할 수도 있고 그렇지 않을 수 있다. 중괄호를 사용하는 경우엔 아래와
        같은 위치에 사용해야 한다.
      </p>
      <p>
        열거형 값에 대한 조건이 아닌 경우, switch 문은 항상
        <code>default</code> 케이스를 포함하는 것이 좋다. (열거형의 경우 
        처리하지 않은 값에 대해 컴파일러가 경고할 것이다.) 만약
        <code>default</code> 케이스가 실행되지 말아야 할 경우 간단히
        <code>assert</code>하라.
      </p>

      <div class=""><pre>switch (var) {
  case 0: {  // 스페이스 2개 들여쓰기
    ...      // 스페이스 4개 들여쓰기
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}</pre></div>


      <p>
        비어 있는 루프는 세미콜론 하나가 아닌 <code>{}</code> 또는
        <code>continue</code>를 사용하는 것이 좋다.
      </p>
      <div class=""><pre>while (condition) {
  // 조건이 false가 될 때까지 반복한다.
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // 좋음 - 비어 있는 루프
while (condition) continue;  // 좋음 - continue로 로직이 없음을 명시함</pre></div>
      <div class=""><pre class="badcode">while (condition);  // 나쁨 - do/while 루프의 일부분으로 보임</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%ED%91%9C%ED%98%84%EC%8B%9D" id="포인터와_레퍼런스_표현식">포인터와 레퍼런스 표현식</a></h3>
<span class="link_button" id="link-포인터와_레퍼런스_표현식__button" name="link-포인터와_레퍼런스_표현식__button"><a href="?showone=%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%ED%91%9C%ED%98%84%EC%8B%9D#%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80_%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4_%ED%91%9C%ED%98%84%EC%8B%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('포인터와_레퍼런스_표현식')" name="포인터와_레퍼런스_표현식__button" id="포인터와_레퍼런스_표현식__button">▶</span>
    <div style="display:inline;" class="">
      마침표나 화살표 좌우에는 스페이스를 사용하지 않는다. 포인터 연산자 뒤에는
      스페이스를 사용하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="포인터와_레퍼런스_표현식__body" id="포인터와_레퍼런스_표현식__body" style="display: none">
      <p>
        다음은 올바르게 작성된 포인터와 레퍼런스 표현식의 예이다.
      </p>
      <div class=""><pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;</pre></div>
      <p>
        다음에 주목하라.
      </p>
      <ul>
        <li> 멤버에 접근할 때 사용하는 마침표나 화살표 좌우에는 스페이스를
             사용하지 않는다.
             </li>
        <li> 포인터 연산자 <code>*</code>이나 <code>&amp;</code> 뒤에는
             스페이스를 사용하지 않는다.
             </li>
      </ul>
      <p>
        포인터 변수나 인자를 선언할 때 *을 타입에 붙여 써도 되고, 변수 이름에
        붙여 써도 된다.
      </p>
      <div class=""><pre>// 앞쪽에 스페이스가 있으므로 괜찮다
char *c;
const string &amp;str;

// 뒤쪽에 스페이스가 있으므로 괜찮다
char* c; // 하지만 다음과 같이 할 것을 기억하라. "char* c, *d, *e, ...;"!
const string&amp; str;</pre></div>
      <div class=""><pre class="badcode">char * c;  // 나쁨 - * 양쪽에 스페이스가 있다
const string &amp; str;  // 나쁨 - &amp; 양쪽에 스페이스가 있다</pre></div>
      <p>
        하나의 파일 안에서 일관되게 작성해야 한다. 그러므로 파일을 수정하는 경우
        그 파일이 사용하는 스타일을 사용하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B6%88%EB%A6%AC%EC%96%B8_%ED%91%9C%ED%98%84%EC%8B%9D" id="불리언_표현식">불리언 표현식</a></h3>
<span class="link_button" id="link-불리언_표현식__button" name="link-불리언_표현식__button"><a href="?showone=%EB%B6%88%EB%A6%AC%EC%96%B8_%ED%91%9C%ED%98%84%EC%8B%9D#%EB%B6%88%EB%A6%AC%EC%96%B8_%ED%91%9C%ED%98%84%EC%8B%9D">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('불리언_표현식')" name="불리언_표현식__button" id="불리언_표현식__button">▶</span>
    <div style="display:inline;" class="">
      <a href="#%EC%A4%84_%EA%B8%B8%EC%9D%B4">정해진 줄 길이</a>보다 긴 불리언 표현식을 사용해야
      할 때에는 줄바꿈을 일관성있게 해야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="불리언_표현식__body" id="불리언_표현식__body" style="display: none">
      <p>
        이 예시에서는 논리적 AND 연산자가 항상 줄의 마지막에 있다.
      </p>
      <div class=""><pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}</pre></div>
      <p>
        이 예시의 줄바꿈에서 <code>&amp;&amp;</code> 연산자가 모두 줄의
        마지막에 있었음에 주목하라. 이 방식은 구글의 코드에서 일반적이나, 모든
        연산자가 줄의 시작 부분에 오도록 줄바꿈하는 것도 허용된다. 가독성을
        높이는 것에 도움이 될 경우 추가적인 괄호를 적절히 사용하여도 좋다.
        또한 <code>and</code>나 <code>compl</code>과 같은 단어로 된 연산자보다
        <code>&amp;&amp;</code>와 <code>~</code>와 같은 기호 연산자를 사용하는
        것이 좋다.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%A6%AC%ED%84%B4%EA%B0%92" id="리턴값">리턴값</a></h3>
<span class="link_button" id="link-리턴값__button" name="link-리턴값__button"><a href="?showone=%EB%A6%AC%ED%84%B4%EA%B0%92#%EB%A6%AC%ED%84%B4%EA%B0%92">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('리턴값')" name="리턴값__button" id="리턴값__button">▶</span>
    <div style="display:inline;" class="">
      <code>return</code> 표현식을 불필요하게 괄호로 묶지 않아야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="리턴값__body" id="리턴값__body" style="display: none">
      <p>
        <code>return expr;</code>에서의 괄호는 <code>x = expr;</code>와 같은
        경우에만 사용한다.
      </p>
      <div class=""><pre>return result;                  // 괄호 사용이 필요없는 간단한 경우
return (some_long_condition &amp;&amp;  // 복잡한 표현식의 가독성을
        another_condition);     // 높일 수 있다면 괄호의 사용이 허용됨</pre></div>
      <div class=""><pre class="badcode">return (value);                // var = (value) 라고 쓰는 경우는 없다.
return(result);                // return 은 함수가 아니다!</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%B3%80%EC%88%98%EC%99%80_%EB%B0%B0%EC%97%B4_%EC%B4%88%EA%B8%B0%ED%99%94" id="변수와_배열_초기화">변수와 배열 초기화</a></h3>
<span class="link_button" id="link-변수와_배열_초기화__button" name="link-변수와_배열_초기화__button"><a href="?showone=%EB%B3%80%EC%88%98%EC%99%80_%EB%B0%B0%EC%97%B4_%EC%B4%88%EA%B8%B0%ED%99%94#%EB%B3%80%EC%88%98%EC%99%80_%EB%B0%B0%EC%97%B4_%EC%B4%88%EA%B8%B0%ED%99%94">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('변수와_배열_초기화')" name="변수와_배열_초기화__button" id="변수와_배열_초기화__button">▶</span>
    <div style="display:inline;" class="">
      <code>=</code>, <code>()</code>, <code>{}</code> 중에서 선택할 수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="변수와_배열_초기화__body" id="변수와_배열_초기화__body" style="display: none">
      <p>
        <code>=</code>, <code>()</code>, <code>{}</code>를 적절히 선택할 수
        있다. 다음 경우가 모두 허용된다.
      </p>
      <div class=""><pre>int x = 3;
int x(3);
int x{3};
string name = "Some Name";
string name("Some Name");
string name{"Some Name"};</pre></div>
      <p>
        <code>initializer_list</code> 생성자가 있는 타입에서 <code>{}</code>를
        사용할 때는 주의해야 한다. <code>{}</code> 문법은 가능한 한
        <code>initializer_list</code> 생성자가 우선시된다.
        <code>initializer_list</code>가 아닌 생성자를 사용하고자 하는 경우
        <code>()</code>를 사용하라.
      </p>
      <div class=""><pre>vector&lt;int&gt; v(100, 1);  // 100개의 1을 포함하는 벡터
vector&lt;int&gt; v{100, 1};  // 100, 1의 두 원소가 있는 벡터</pre></div>
      <p>
        또한 중괄호 형식은 정밀도를 낮추는 타입 캐스트를 막아주므로 이러한
        프로그래밍 에러를 미연에 방지할 수 있다.
      </p>
      <div class=""><pre>int pi(3.14);  // 좋음 -- pi == 3.
int pi{3.14};  // 컴파일 에러: 정밀도를 낮추는 캐스트</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%A7%80%EC%8B%9C%EC%9E%90" id="전처리기_지시자">전처리기 지시자</a></h3>
<span class="link_button" id="link-전처리기_지시자__button" name="link-전처리기_지시자__button"><a href="?showone=%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%A7%80%EC%8B%9C%EC%9E%90#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0_%EC%A7%80%EC%8B%9C%EC%9E%90">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('전처리기_지시자')" name="전처리기_지시자__button" id="전처리기_지시자__button">▶</span>
    <div style="display:inline;" class="">
      전처리기 지시자 시작 부분에 사용되는 # 기호는 항상 그 줄의 처음에
      있어야 한다.
    </div>
    <div class=""><div class="stylepoint_body" name="전처리기_지시자__body" id="전처리기_지시자__body" style="display: none">
      <p>
        전처리기 지시자가 들여쓰기된 코드의 내부에 있을 때에도 줄의 처음부터
        시작해야 한다.
      </p>
      <div class=""><pre>// 좋음 - 지시자가 줄의 처음부터 시작하는 예
  if (lopsided_score) {
#if DISASTER_PENDING  // 좋음 -- 줄의 처음부터 시작함
    DropEverything();
# if NOTIFY           // # 다음의 스페이스는 허용되지만 필수는 아니다.
    NotifyClient();
# endif
#endif
    BackToNormal();
  }</pre></div>
      <div class=""><pre class="badcode">// 나쁨 - 지시자가 들여쓰기되어 있음
  if (lopsided_score) {
    #if DISASTER_PENDING  // 틀림! "#if"는 줄의 처음에 있어야 함
    DropEverything();
    #endif                // 틀림! "#endif"를 들여쓰기해서는 안됨
    BackToNormal();
  }</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%ED%81%B4%EB%9E%98%EC%8A%A4_%ED%8F%AC%EB%A7%B7" id="클래스_포맷">클래스 포맷</a></h3>
<span class="link_button" id="link-클래스_포맷__button" name="link-클래스_포맷__button"><a href="?showone=%ED%81%B4%EB%9E%98%EC%8A%A4_%ED%8F%AC%EB%A7%B7#%ED%81%B4%EB%9E%98%EC%8A%A4_%ED%8F%AC%EB%A7%B7">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('클래스_포맷')" name="클래스_포맷__button" id="클래스_포맷__button">▶</span>
    <div style="display:inline;" class="">
      <code>public</code>, <code>protected</code>, <code>private</code> 순서로
      각각 스페이스 하나씩 들여쓰기하여 클래스 본문을 구성한다.
    </div>
    <div class=""><div class="stylepoint_body" name="클래스_포맷__body" id="클래스_포맷__body" style="display: none">
      <p>
        기본적인 포맷은 다음과 같다. (주석은 제외한다. 주석에 대해서는
        <a href="#%ED%81%B4%EB%9E%98%EC%8A%A4_%EC%A3%BC%EC%84%9D">클래스 주석</a>을 참조하라.)
      </p>
      <div class=""><pre>class MyClass : public OtherClass {
 public:      // 스페이스 하나 들여쓰기에 주목!
  MyClass();  // 보통의 스페이스 2개 들여쓰기
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
  DISALLOW_COPY_AND_ASSIGN(MyClass);
};</pre></div>
      <p>
        주의할 점:
      </p>
      <ul>
        <li> 줄 길이 제한에 위배되지 않는 한 상위 클래스의 이름은 하위 클래스의
             이름과 같은 줄에 있어야 한다.
             </li>
        <li> <code>public:</code>, <code>protected:</code>,
             <code>private:</code> 키워드는 스페이스 하나로 들여쓰기한다.
             </li>
        <li> 첫번째로 사용되는 경우를 제외하고는 이들 키워드의 이전에 빈 줄을
             삽입한다. 작은 클래스의 경우 이 규칙은 필수사항이 아니다.
             </li>
        <li> 이들 키워드 이후에는 빈 줄을 삽입하지 않는다.
             </li>
        <li> <code>public</code> 부분이 처음으로 와야 하고, 그 다음으로
             <code>protected</code> 부분이, 마지막으로 <code>private</code>
             부분이 와야 한다.
             </li>
        <li> 이들 각자의 내부에서 사용되는 선언의 순서에 관해서는
             <a href="#%EC%84%A0%EC%96%B8_%EC%88%9C%EC%84%9C">선언 순서</a>를 참조한다.
             </li>
      </ul>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%83%9D%EC%84%B1%EC%9E%90_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8" id="생성자_초기화_리스트">생성자 초기화 리스트</a></h3>
<span class="link_button" id="link-생성자_초기화_리스트__button" name="link-생성자_초기화_리스트__button"><a href="?showone=%EC%83%9D%EC%84%B1%EC%9E%90_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8#%EC%83%9D%EC%84%B1%EC%9E%90_%EC%B4%88%EA%B8%B0%ED%99%94_%EB%A6%AC%EC%8A%A4%ED%8A%B8">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('생성자_초기화_리스트')" name="생성자_초기화_리스트__button" id="생성자_초기화_리스트__button">▶</span>
    <div style="display:inline;" class="">
      생성자 초기화 리스트는 모두 한 줄에 쓰거나, 스페이스 4개로 들여쓰기하여
      각각 다음 줄에 작성할 수 있다.
    </div>
    <div class=""><div class="stylepoint_body" name="생성자_초기화_리스트__body" id="생성자_초기화_리스트__body" style="display: none">
      <p>
        다음은 초기화 리스트로 허용가능한 두 가지의 포맷이다.
      </p>
      <div class=""><pre>// 모두 한 줄에 쓸 수 있는 경우
MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {}</pre></div>
      <p>
        혹은
      </p>
      <div class=""><pre>// 여러 줄에 써야 할 경우 스페이스 4개로 들여쓰기하고
// : 기호를 초기화 리스트의 첫 번째 줄에 쓴다.
MyClass::MyClass(int var)
    : some_var_(var),             // 스페이스 4개 들여쓰기
      some_other_var_(var + 1) {  // 줄맞춤
  ...
  DoSomething();
  ...
}</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%ED%8F%AC%EB%A7%A4%ED%8C%85" id="네임스페이스_포매팅">네임스페이스 포매팅</a></h3>
<span class="link_button" id="link-네임스페이스_포매팅__button" name="link-네임스페이스_포매팅__button"><a href="?showone=%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%ED%8F%AC%EB%A7%A4%ED%8C%85#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4_%ED%8F%AC%EB%A7%A4%ED%8C%85">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('네임스페이스_포매팅')" name="네임스페이스_포매팅__button" id="네임스페이스_포매팅__button">▶</span>
    <div style="display:inline;" class="">
      네임스페이스의 내부는 들여쓰기하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="네임스페이스_포매팅__body" id="네임스페이스_포매팅__body" style="display: none">
      <p>
        <a href="#%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4">네임스페이스</a>는 들여쓰기 단계를 증가시키지
        않는다. 예를 들면
      </p>
      <div class=""><pre>namespace {

void foo() {  // 맞음. 네임스페이스 내부에 추가적인 들여쓰기 없음
  ...
}

}  // namespace</pre></div>
      <p>
        네임스페이스 내부에 추가적으로 들여쓰기를 하지 않는다.
      </p>
      <div class=""><pre class="badcode">namespace {

  // 틀림. 들여쓰기를 하지 말아야 함
  void foo() {
    ...
  }

}  // namespace</pre></div>
      <p>
        중첩된 네임스페이스를 사용할 경우 각각을 한 줄에 작성한다.
      </p>
      <div class=""><pre>namespace foo {
namespace bar {</pre></div>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EA%B0%80%EB%A1%9C_%EA%B3%B5%EB%B0%B1" id="가로_공백">가로 공백</a></h3>
<span class="link_button" id="link-가로_공백__button" name="link-가로_공백__button"><a href="?showone=%EA%B0%80%EB%A1%9C_%EA%B3%B5%EB%B0%B1#%EA%B0%80%EB%A1%9C_%EA%B3%B5%EB%B0%B1">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('가로_공백')" name="가로_공백__button" id="가로_공백__button">▶</span>
    <div style="display:inline;" class="">
      가로 공백을 사용하는 것은 경우에 따라 다르다. 줄 끝에는 공백 문자를
      사용하지 않는다.
    </div>
    <div class=""><div class="stylepoint_body" name="가로_공백__body" id="가로_공백__body" style="display: none">
      <p class="">
<span class="stylepoint_subsection">일반 사항</span>
        </p><div class=""><pre>void f(bool b) {  // 여는 중괄호 앞에는 항상 스페이스가 있어야 함
  ...
int i = 0;  // 세미콜론 앞에는 대개 스페이스가 없음
int x[] = { 0 };  // 중괄호 초기화 리스트 내부의 스페이스는 선택사항
int x[] = {0};    // 사용할 경우엔 양 쪽에 모두 사용해야 한다!
// 상속과 초기화 리스트의 콜론 전후에는 스페이스를 사용한다.
class Foo : public Bar {
 public:
  // 인라인 함수 구현에는 중괄호와 구현체 사이에 스페이스를 사용한다.
  Foo(int b) : Bar(), baz_(b) {}  // 빈 중괄호 사이에는 스페이스 없음
  void Reset() { baz_ = 0; }  // 중괄호와 구현체를 구분하는 스페이스
  ...</pre></div>
        <p>
          줄 끝에 공백 문자를 붙이면 같은 파일을 편집하는 다른 사람이 기존의
          뒤쪽 공백 문자를 삭제할 경우, 파일 병합 시에 할 일이 늘어난다.
          그러므로 줄 끝에는 공백문자를 사용하지 말라. 이미 해당 줄을 수정하고
          있다면 삭제하고, 그렇지 않다면 (가능하면 다른 사람이 그 파일을
          사용하고 있지 않을 때) 별도의 정리 작업을 통해서 삭제하라.
        </p>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">반복문과 조건문</span>
        </p><div class=""><pre>if (b) {          // 조건문과 반복문 키워드 다음에 스페이스
} else {          // else 전후에 스페이스
}
while (test) {}   // 대개 괄호 사이에는 스페이스 없음
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
switch ( i ) {    // 반복문과 조건문의 괄호 사이에는 스페이스가 있어도
if ( test ) {     // 되지만 드문 경우이다. 일관성 있게 사용하라
for ( int i = 0; i &lt; 5; ++i ) {
for ( ; i &lt; 5 ; ++i) { // for 반복문은 항상 세미콜론 다음에
  ...                  // 스페이스를 사용하며 세미콜론 이전에
                       // 스페이스를 사용할 수도 있다.
for (auto x : counts) {   // 범위 기반 for 반복문은 항상
  ...                     // : 전후에 스페이스를 사용한다.
}
switch (i) {
  case 1:         // 스위치 문의 case 에서는 : 전에 스페이스가 없음
    ...
  case 2: break;  // 코드가 뒤에 있는 경우 : 다음에 스페이스를 사용함</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">연산자</span>
        </p><div class=""><pre>x = 0;              // 대입 연산자 전후에는 항상 스페이스를 사용

x = -5;             // 단항 연산자와 그 인자 사이에는
++x;                // 스페이스를 사용하지 않는다.
if (x &amp;&amp; !y)
  ...
v = w * x + y / z; // 이진 연산자는 대개 좌우에 스페이스를 사용하지만
v = w*x + y/z;     // 각 항마다 스페이스를 사용하지 않는 것도 허용한다
v = w * (x + z);   // 괄호 사이에는 스페이스가 없는 것이 좋다.</pre></div>
      <p></p>
      <p class="">
<span class="stylepoint_subsection">템플릿과 캐스트</span>
        </p><div class=""><pre>vector&lt;string&gt; x;          // 꺾쇠(&lt;와 &gt;) 사이와 &lt; 이전,
y = static_cast&lt;char*&gt;(x); // 캐스트의 &gt;( 사이에는
                           // 스페이스를 사용하지 않는다.
vector&lt;char *&gt; x;          // 타입과 포인터 사이의 스페이스는
                           // 허용되지만 일관성이 있어야 한다.
set&lt;list&lt;string&gt;&gt; x;   // C++11 코드에서 허용됨
set&lt;list&lt;string&gt; &gt; x;  // C++03 은 &gt; &gt;를 써야 함
set&lt; list&lt;string&gt; &gt; x; // 대칭을 위해 선택적으로
                       // &lt; &lt;에도 스페이스를 사용할 수 있다.</pre></div>
      <p></p>
    </div></div>
  </div>


  <div class="">
<h3><a name="%EC%84%B8%EB%A1%9C_%EA%B3%B5%EB%B0%B1" id="세로_공백">세로 공백</a></h3>
<span class="link_button" id="link-세로_공백__button" name="link-세로_공백__button"><a href="?showone=%EC%84%B8%EB%A1%9C_%EA%B3%B5%EB%B0%B1#%EC%84%B8%EB%A1%9C_%EA%B3%B5%EB%B0%B1">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('세로_공백')" name="세로_공백__button" id="세로_공백__button">▶</span>
    <div style="display:inline;" class="">
      세로 공백의 사용을 최소화하라
    </div>
    <div class=""><div class="stylepoint_body" name="세로_공백__body" id="세로_공백__body" style="display: none">
      <p>
        이것은 규칙보단 원칙에 가깝다. 꼭 필요한 경우가 아니면 빈 줄을 사용하지
        말라. 특히 함수 사이에 한 개 또는 두 개보다 많은 빈 줄을 추가하지 말라.
        함수를 시작할 때 비어 있는 줄로 시작하지 않도록 노력하고, 끝낼 때에도
        빈 줄을 사용하지 않아야 한다. 함수 내부에서도 빈 줄 사용을 절제하라.
      </p>
      <p>
        기본 원칙은 더 많은 코드가 스크린에 들어올수록 프로그램의 제어 흐름을
        따라가고 이해하기가 쉬워진다는 것이다. 물론 지나치게 조밀한 코드도
        지나치게 펼쳐진 코드만큼 가독성을 해칠 수 있으므로 각자 판단에 따르도록
        한다. 하지만 세로 공백의 사용을 전반적으로 최소화하라.
      </p>
      <p>
        빈 줄 사용과 관련해 유용할 수 있는 몇 가지 기본 규칙:
      </p>
      <ul>
        <li> 함수의 시작이나 끝에 사용하는 빈 줄은 가독성에 거의 도움을
             주지 않는다.
             </li>
        <li> if-else 체인의 내부에 있는 빈 줄은 가독성에 도움을 줄 수 있다.
             </li>
      </ul>
    </div></div>
  </div>
</div>

<div class="">
<h2 name="규칙의_예외사항" id="규칙의_예외사항">규칙의 예외사항</h2>
  <p>
    지금까지 설명한 코딩 컨벤션은 강제적이지만 다른 모든 좋은 규칙들처럼
    이것에도 예외사항이 있으며, 그 예외사항을 여기에서 다룬다.
  </p>

  <div class="">
<h3><a name="%EA%B7%9C%EC%B9%99%EC%9D%84_%EC%A7%80%ED%82%A4%EC%A7%80_%EC%95%8A%EB%8A%94_%EA%B8%B0%EC%A1%B4_%EC%BD%94%EB%93%9C" id="규칙을_지키지_않는_기존_코드">규칙을 지키지 않는 기존 코드</a></h3>
<span class="link_button" id="link-규칙을_지키지_않는_기존_코드__button" name="link-규칙을_지키지_않는_기존_코드__button"><a href="?showone=%EA%B7%9C%EC%B9%99%EC%9D%84_%EC%A7%80%ED%82%A4%EC%A7%80_%EC%95%8A%EB%8A%94_%EA%B8%B0%EC%A1%B4_%EC%BD%94%EB%93%9C#%EA%B7%9C%EC%B9%99%EC%9D%84_%EC%A7%80%ED%82%A4%EC%A7%80_%EC%95%8A%EB%8A%94_%EA%B8%B0%EC%A1%B4_%EC%BD%94%EB%93%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('규칙을_지키지_않는_기존_코드')" name="규칙을_지키지_않는_기존_코드__button" id="규칙을_지키지_않는_기존_코드__button">▶</span>
    <div style="display:inline;" class="">
      이 스타일 가이드를 따르지 않는 코드를 다룰 때에는 규칙을 지키지 않을 수
      있다.
    </div>
    <div class=""><div class="stylepoint_body" name="규칙을_지키지_않는_기존_코드__body" id="규칙을_지키지_않는_기존_코드__body" style="display: none">
      <p>
        이 가이드가 아닌 다른 규칙에 따라 작성된 코드를 수정하는 경우엔
        이 규칙이 아닌 그 코드의 컨벤션에 따라 일관성있게 코드를 작성해야 한다.
        어떻게 작성해야 할 지 명확하지 않은 경우 그 코드의 원작자나 현재
        담당자에게 문의하라. <em>일관성</em>은 파일 내의 일관성도 포함한다는
        것을 기억하라.
      </p>
    </div></div>
  </div>

  <div class="">
<h3><a name="%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C" id="윈도우_코드">윈도우 코드</a></h3>
<span class="link_button" id="link-윈도우_코드__button" name="link-윈도우_코드__button"><a href="?showone=%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C#%EC%9C%88%EB%8F%84%EC%9A%B0_%EC%BD%94%EB%93%9C">
          link
        </a></span><span class="showhide_button" onclick="javascript:ShowHideByName('윈도우_코드')" name="윈도우_코드__button" id="윈도우_코드__button">▶</span>
    <div style="display:inline;" class="">
      윈도우 프로그래머는 그들만의 코딩 컨벤션을 발전시켜 왔으며, 대개
      윈도우 헤더와 다른 마이크로소프트 코드의 컨벤션을 따른다.
      누구의 코드이든 모두가 쉽게 이해하도록 하기 위해 플랫폼과 관계 없이
      C++을 쓰는 모든 사람을 위해 한 종류의 가이드라인만을 정한다.
    </div>
    <div class=""><div class="stylepoint_body" name="윈도우_코드__body" id="윈도우_코드__body" style="display: none">
      <p>
        일반적인 윈도우 스타일의 코드에 익숙하다면 잊기 쉬운 가이드 라인의
        몇몇 부분을 복습하는 것이 유익하다.
      </p>
      <ul>
        <li> (예를 들어 정수를 <code>iNum</code>로 이름 짓는 등의) 헝가리안
             표기법을 사용하지 않는다. 소스 파일의 <code>.cc</code> 확장자를
             포함하여 구글의 작명 컨벤션을 사용해야 한다.
             </li>
        <li> 윈도우는 <code>DWORD</code>, <code>HANDLE</code>등과 같은
             그들만의 타입 동의어를 정의한다. 이것들을 윈도우 API 함수를
             호출할 때 사용하는 것은 전혀 문제가 없고 사용이 권장된다.
             하지만 가능한 실제 C++ 타입과 가장 가까운 것을 사용하도록 한다.
             예를 들면, <code>LPCTSTR</code>보다 <code>const TCHAR *</code>를
             사용하는 것이 좋다.
             </li>
        <li> Microsoft Visual C++에서 컴파일할 때는 컴파일러의 경고 레벨을
             3 이상으로 설정하고, 모든 경고를 에러로 처리하라.
             </li>
        <li> <code>#pragma once</code>를 사용하지 말고, 구글의 표준 인클루드
             가드를 사용하라. 인클루드 가드에 사용되는 경로는 프로젝트 트리를
             기준으로 하는 상대경로를 사용하라.
             </li>
        <li> 절대적으로 필요한 경우가 아니라면, <code>#pragma</code>나
             <code>__declspec</code> 같은 비표준 확장의 사용을 지양하라.
             <code>__declspec(dllimport)</code>와
             <code>__declspec(dllexport)</code>의 사용은 허용한다.
             하지만 코드를 공유할 때 손쉽게 비활성화할 수 있도록
             <code>DLLIMPORT</code>와 <code>DLLEXPORT</code>와 같은
             매크로를 통해 사용해야 한다.
             </li>
      </ul>
      <p>
        하지만 윈도우에서 규칙을 지키지 않아도 되는 것도 몇몇 있다.
      </p>
      <ul>
        <li> 일반적으로 <a href="#%EB%8B%A4%EC%A4%91_%EC%83%81%EC%86%8D">다중 상속의 사용은
             금지되지만</a>, COM이나 일부 ATL/WTL 클래스를 사용할 때는 이것이
             꼭 필요하다. COM이나 ATL/WTL 클래스와 인터페이스에는 다중 구현
             상속을 사용할 수 있다.
             </li>
        <li> 직접 작성한 코드에는 예외를 사용하지 않는 것이 좋으나,
             Visual C++이 제공하는 것을 포함해 ATL과 일부 STL에는 예외가
             광범위하게 사용된다. ATL을 사용할 때에는
             <code>_ATL_NO_EXCEPTIONS</code>를 정의하여 예외를 비활성화할 수
             있다. STL에서도 예외를 비활성화할 수 있는 옵션이 있는지 알아보고
             가능하면 비활성화하는 것이 좋다. 그렇지 않은 경우 컴파일러의 예외
             옵션을 켜 두는 것은 허용한다. (하지만 이것은 오로지 STL이
             컴파일되도록 하기 위함이고, 여전히 예외 처리 코드는 작성하지
             않아야 한다.)
             </li>
        <li> 미리 컴파일된 헤더를 사용하는 일반적인 방법은 모든 소스 파일의
             첫 줄에 <code>Stdafx.h</code>나 <code>precompile.h</code>를
             인클루드하는 것이다. 다른 프로젝트와의 코드를 쉽게 공유할 수
             있도록 (<code>precompile.cc</code>)를 제외하고는 이 파일을
             명시적으로 인클루드하는 것을 피하고 <code>/Fl</code> 컴파일러
             옵션을 통해 자동으로 인클루드되도록 하라.
             </li>
        <li> 대개 <code>resources.h</code>라는 이름이 붙는 리소스 헤더들은
             매크로만을 포함하므로 이 스타일 가이드라인의 제약을 받지 않는다.
             </li>
      </ul>
    </div></div>
  </div>


</div>

<h2>맺음말</h2>
  <p>
    상식적이고 <em>일관성</em>있게 작성하라.
  </p>
  <p>
    코드를 수정하는 경우 몇 분 정도 주변의 코드를 살펴보고 그것의 스타일을
    판단하라. 그 코드가 <code>if</code>문 주변에 스페이스를 사용한다면
    그것에 따라야 한다. 만약 그 코드의 주석들이 작은 박스와 별표들을 사용한다면
    새로 작성하는 코드도 작은 박스와 별표를 사용해야 한다.
  </p>
  <p>
    스타일 가이드라인의 요점은 코딩에 있어서 공통적인 어휘를 가짐으로써
    사람들이 서로의 말하는 방식보다 내용에 집중할 수 있게 하기 위함이고,
    여기에 전체적인 스타일 규칙을 소개하는 것은 사람들이 그 어휘를
    알게 하기 위함이다. 하지만 부분적인 스타일 규칙도 중요하다.
    어떤 파일에 다른 부분과 심하게 달라 보이는 코드를 추가하는 경우
    그 불연속성은 다른 사람들이 그 코드를 읽는 리듬을 벗어나게 할 것이다.
    그렇게 하지 말자.
  </p>

  <p>
    그러면 코드를 쓰는 방법에 대해서 충분히 쓴 것 같다. 코드 자체가 더 재미있을
    것이다. 즐거운 코딩!
  </p>


<hr>

<p align="right">
Revision 3.274
</p>



<address>
Benjy Weinberger<br>
Craig Silverstein<br>
Gregory Eitzmann<br>
Mark Mentovai<br>
Tashana Landray
</address>

</body>

</html>
